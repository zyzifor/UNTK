FUNCTION processVlv
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Name            Data Type      Dimension            Direction  Attribute       Comment                             *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* processVlv     DINT                                VarOutput  Write           Результат выполнения функции *)
(* iVlv            typVlv                              Var        Read/Write      Рабочий объект *)
(* i               DINT                                Var        Read/Write      Счётчик *)
(* _bRes           BOOL                                Var        Read/Write      Результат функции BOOL *)
(* _dRes           DINT                                Var        Read/Write      Результат функции DINT *)
(* ------------------------------------------------------------------------------------------------------------------ *)
processVlv:= sVlv.iSize;
if sVlv.iSize>sVlv.iMax then processVlv:= -sVlv.iSize; return; end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Проход по всем параметрам *)
i:= 1;   while i<= sVlv.iSize do
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Отключение резевных объектов *)
if not dVlv[i].nLogicNot then
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Передача в Рабочий объект *)
  iVlv:= dVlv[i];
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сохраняемые переменные (чтение при первом скане) *)
  if iPrgModify then
    iVlv.rAuto          := rVlv[i].rAuto;                        (* Режим Автомат *) 
    iVlv.rHandle        := rVlv[i].rHandle;                      (* Режим Ручной *)  
    iVlv.rRepair        := rVlv[i].rRepair;                      (* Режим Ремонт *)  
    iVlv.sImit          := rVlv[i].sImit;                        (* Имитация *)      
    iVlv.sDist          := rVlv[i].sDist;                        (* Управление Дистанционное *)
    iVlv.sError         := rVlv[i].sError;                       (* Общая неисправность *)
    iVlv.sModbus        := rVlv[i].sModbus;                      (* Управление по Modbus *)
    iVlv.lOpen          := rVlv[i].lOpen;                        (* Открыть (внутр.) *)
    iVlv.lClose         := rVlv[i].lClose;                       (* Закрыть (внутр.) *)
    iVlv.lStop          := rVlv[i].lStop;                        (* Стоп (внутр.) *) 
    iVlv.lDist          := rVlv[i].lDist;                        (* Дист. управление (внутр.) *)
    iVlv.xErrOpenR      := rVlv[i].xErrOpenR;                    (* КВ открытия (Резерв). Неисправность канала *)
    iVlv.xErrCloseR     := rVlv[i].xErrCloseR;                   (* КВ закрытия (Резерв). Неисправность канала *)
    iVlv.yOpen          := rVlv[i].yOpen;                        (* Открыть *)       
    iVlv.yClose         := rVlv[i].yClose;                       (* Закрыть *)       
    iVlv.yStop          := rVlv[i].yStop;                        (* Стоп *)          
    iVlv.yDist          := rVlv[i].yDist;                        (* Включить Управление Дистанционное *)
  end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Начало логики *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сброс деблокироки неисправности дополнительного источника *)
iVlv.fcDeblSrs:= false; 	(* Деблокировать неисправность дополнительного источника (ModBus>вспом. устройство) *)
iVlv.fcDeblSrs:= iVlv.cDebl;
(* -------------------------------- *)
(* Имитация*)  
   iVlv.sImit:= (iVlv.sImit or iVlv.cImitOn) & not iVlv.cImitOff;
  (* ------------------------------ *)
  (* Состояния в режиме имитации *)
  if iVlv.sImit then
    iVlv.sReady := TRUE;                                                    (* Готов к управлению  *)
    iVlv.sPower := TRUE;                                                    (* Есть напряжение в схеме управления *)
	iVlv.xErrSrs:= false;                                                   (* Нисрпвность от внешнего источника *)
    (* ----------------------------------------------*)
    if not iVlv.nDistOper then                                          (* Дистанционное управление от ключа *)
      iVlv.sDist := iVlv.nDist;                                         (* - Положение "Дист" *)   
      iVlv.sLocal:= FALSE;                                              (* - Положение "Мест" *)
    else
	  (* Дистанционное управление от АРМ *)
	  iVlv.sDist:= (iVlv.sDist or iVlv.cDistOn) & not iVlv.cDistOff;    (* - Положение "Дист" *)
      iVlv.sLocal:= not iVlv.sDist;                                     (* - Положение "Мест" *)
    end_if;
    iVlv.sNo   := not iVlv.sDist & not iVlv.sLocal & iVlv.nDist;        (* - Положение "Откл" ??? (Почему в ветке имитации)*)
    (* ------------------------------*)
	(* Расчёт уставок рабочих таймеров в имитации *)
    if iVlv.tTimer2>0 then _tempREAL2:= _tTimer(iVlv.tTimer2)-dDtTm[1].MSec; else _tempREAL2:=  1.0; end_if;
    if iVlv.tTimer3>0 then _tempREAL3:= _tTimer(iVlv.tTimer3)-dDtTm[1].MSec; else _tempREAL3:= 10.0; end_if; 
	(* Работа таймера имитации mTimer8 *)
    if iVlv.fOpening                   then iVlv.mTimer8:= iVlv.mTimer8+dDtTm[1].MSec; end_if;
    if iVlv.fClosing                   then iVlv.mTimer8:= iVlv.mTimer8-dDtTm[1].MSec; end_if;
    if iVlv.fOpen  & not iVlv.fClosing then iVlv.mTimer8:= _tTimer(iVlv.tTimer3);      end_if;
    if iVlv.fClose & not iVlv.fOpening then iVlv.mTimer8:= 0.0;                        end_if;
    if iVlv.nxCV  then 
		if _tempREAL3>0.0 then iVlv.Percent:= iVlv.mTimer8/_tTimer(iVlv.tTimer3)*100.0;	   end_if;
	end_if;
	(* Положения в имитации *)
    iVlv.fOpen   := (iVlv.mTimer8>=_tempREAL3-_tempREAL2) & 
	                not (iVlv.fClosing & (iVlv.mTimer8<_tTimer(iVlv.tTimer3)-_tempREAL2+_tTimer(iVlv.tTimer1))); 
    iVlv.fClose  := (iVlv.mTimer8<=0.0       +_tempREAL2) & 
	                not (iVlv.fOpening & (iVlv.mTimer8>0.0                  +_tempREAL2-_tTimer(iVlv.tTimer1)));
    iVlv.fOpening:= (iVlv.fOpening or (iVlv.lOpen  & (iVlv.mTimer1>=(_tTimer(iVlv.tTimer1)-dDtTm[1].MSec) or _tTimer(iVlv.tTimer1)=0.0))) &
                    not (iVlv.lStop  & (iVlv.mTimer1>=(_tTimer(iVlv.tTimer1)-dDtTm[1].MSec) or _tTimer(iVlv.tTimer1)=0.0)) &
                    not  iVlv.fOpen;
    iVlv.fClosing:= (iVlv.fClosing or (iVlv.lClose & (iVlv.mTimer1>=(_tTimer(iVlv.tTimer1)-dDtTm[1].MSec) or _tTimer(iVlv.tTimer1)=0.0))) &
                    not (iVlv.lStop  & (iVlv.mTimer1>=(_tTimer(iVlv.tTimer1)-dDtTm[1].MSec) or _tTimer(iVlv.tTimer1)=0.0)) &
                    not  iVlv.fClose;
    (* Состояния для имитации *)
    if not iVlv.nInvert then
      iVlv.xOpen := iVlv.fOpen;
      iVlv.xClose:= iVlv.fClose;
    else
      iVlv.xOpen := not iVlv.fOpen;
      iVlv.xClose:= not iVlv.fClose;
    end_if;
    iVlv.xOpening := iVlv.fOpening;
    iVlv.xClosing := iVlv.fClosing;
    iVlv.xOpenFlt := false;
    iVlv.xCloseFlt:= false;
    iVlv.xExtErr  := false;
    iVlv.xErrMB   := false;
  (* ------------------------------ *)
  (* Состояния без имитации*)    
  else 
    (* ------------------------------*)
    (* Резервирование каналов *)
	(* КВ открытия *)
	if iVlv.nOpenR    then  
	  iVlv.xOpen  := ((not iVlv.xErrOpen   & not iVlv.xErrOpenR)   & (iVlv.xOpen   or iVlv.xOpenR)) or 
	                 ((not iVlv.xErrOpen   &     iVlv.xErrOpenR)   &  iVlv.xOpen) or
	                 ((    iVlv.xErrOpen   & not iVlv.xErrOpenR)   &  iVlv.xOpenR);
    end_if;
	(* КВ закрытия *)
	if iVlv.nCloseR  then
	  iVlv.xClose := ((not iVlv.xErrClose  & not iVlv.xErrCloseR)  & (iVlv.xClose  or iVlv.xCloseR)) or
	                 ((not iVlv.xErrClose  &     iVlv.xErrCloseR)  &  iVlv.xClose) or
					 ((    iVlv.xErrClose  & not iVlv.xErrCloseR)  &  iVlv.xCloseR);
    end_if;
    (* Неисправность канала КВ открытия/закрытия ( NAMUR ) *)
	iVlv.exOpenFlt := iVlv.xErrOpen;             (* Неисправна цепь КВ Открытия *)
    iVlv.exCloseFlt:= iVlv.xErrClose;            (* Неисправна цепь КВ Закрытия *)
	
	(* Управление Дистанционное *)
	if iVlv.nDistR   then
	  iVlv.xDist  := ((not iVlv.xErrDist   & not iVlv.xErrDistR)   & (iVlv.xDist   or iVlv.xDistR)) or
	                 ((not iVlv.xErrDist   &     iVlv.xErrDistR)   &  iVlv.xDist) or
					 ((    iVlv.xErrDist   & not iVlv.xErrDistR)   &  iVlv.xDistR);
    end_if;
	(* Неисправность схемы управления *)
	if iVlv.nExtErrR then 
	  iVlv.xExtErr:= ((not iVlv.xErrExtErr & not iVlv.xErrExtErrR) & (iVlv.xExtErr or iVlv.xExtErrR)) or
	                 ((not iVlv.xErrExtErr &     iVlv.xErrExtErrR) &  iVlv.xExtErr) or
					 ((    iVlv.xErrExtErr & not iVlv.xErrExtErrR) &  iVlv.xExtErrR);
    end_if;					 
    (* ------------------------------*)
    iVlv.sPower:= iVlv.xPower or not iVlv.nPower;                (* Готов к управлению*)
    iVlv.sReady:= iVlv.xReady or not iVlv.nReady;                (* Есть напряжение в схеме управления*)
    (* ------------------------------*)
    if not iVlv.nDistOper then                                   (* Дистанционное управление от ключа*)
      iVlv.sDist := iVlv.xDist & not iVlv.xLocal;                (* - Положение "Дист"*)    
      iVlv.sLocal:= iVlv.xLocal;                                 (* - Положение "Мест"*)
    else 
	  (* Дистанционное управление от АРМ *)
	  iVlv.sDist:= (iVlv.sDist or iVlv.cDistOn) & not iVlv.cDistOff;    (* - Положение "Дист" *)
      iVlv.sLocal:= not iVlv.sDist;                                     (* - Положение "Мест" *)
      iVlv.lDist  := iVlv.sDist;                                        (* - Дист. управление*)
    end_if;
    iVlv.sNo    := not iVlv.sDist & not iVlv.sLocal & iVlv.nDist;       (* - Положение "Откл"*)
    (* Состояния для имитации*)
    iVlv.fOpen   := iVlv.xOpen;
    iVlv.fClose  := iVlv.xClose;
    iVlv.fOpening:= iVlv.xOpening;
    iVlv.fClosing:= iVlv.xClosing;
    if (iVlv.sInter or iVlv.ePosition) then iVlv.mTimer8:= _tempREAL3/2.0; end_if;  (*...необходимо ли ???*)
  end_if; 
(* ---------------------------------------------------- *)
(* Питание *)
  iVlv.sNotPower:= iVlv.nPower & not iVlv.sPower;
(* ---------------------------------------------------- *)
(* Готовность *)
  iVlv.sNotReady:= iVlv.nReady & not iVlv.sReady;
(* ---------------------------------------------------- *)
(* Положения *)
  iVlv.sOpen   := (not iVlv.nInvert & iVlv.xOpen)  or (iVlv.nInvert & not iVlv.xOpen);
  iVlv.sClose  := (not iVlv.nInvert & iVlv.xClose) or (iVlv.nInvert & not iVlv.xClose);
  iVlv.sOpening:= (iVlv.nMoving & iVlv.xOpening) or 
                  (not iVlv.nKeep & not iVlv.nMoving & ((iVlv.lOpen  & (_tTimer(iVlv.tTimer2)>0.0 or _tTimer(iVlv.tTimer2)=0.0)) or (iVlv.sOpening & not iVlv.sOpen  & not iVlv.lStop & not iVlv.sError))) or 
				  (iVlv.nKeep & iVlv.lOpen  & iVlv.mTimer3>0.1);
  iVlv.sClosing:= (iVlv.nMoving & iVlv.xClosing) or 
                  (not iVlv.nKeep & not iVlv.nMoving & ((iVlv.lClose & (_tTimer(iVlv.tTimer2)>0.0 or _tTimer(iVlv.tTimer2)=0.0)) or (iVlv.sClosing & not iVlv.sClose & not iVlv.lStop & not iVlv.sError))) or 
				  (iVlv.nKeep & iVlv.lClose & iVlv.mTimer3>0.1);
  iVlv.sInter  := not iVlv.sOpen & not iVlv.sClose;
(* ---------------------------------------------------- *)
(* Использовать: Процент откытия (внешний) *)
  if iVlv.nxPercent & not iVlv.sImit then iVlv.Percent:= iVlv.xPercent; end_if;
(* ---------------------------------------------------- *)
(* Блокировка автоматических команд *)
  iVlv.cOpenAuto := iVlv.cOpenAuto  & ((iVlv.nMode & iVlv.rAuto) or not iVlv.nMode);
  iVlv.cCloseAuto:= iVlv.cCloseAuto & ((iVlv.nMode & iVlv.rAuto) or not iVlv.nMode);
  iVlv.cStopAuto := iVlv.cStopAuto  & ((iVlv.nMode & iVlv.rAuto) or not iVlv.nMode);
(* ---------------------------------------------------- *)
(* Команды от внешних Dso *)
  iVlv.eDsoCmd    := false;               (* Невыполнение команды (Безопасный режим) *)
  iVlv.fDsoStopOn := false;               (* Воздействие ПАЗ активно. Стоп (Безопасный режим) *)
  iVlv.fDsoOpenOn := false;               (* Воздействие ПАЗ активно. Открыть (Безопасный режим) *)
  iVlv.fDsoCloseOn:= false;               (* Воздействие ПАЗ активно. Закрыть (Безопасный режим) *)
(* Стоп (Безопасный режим) *)
  If iVlv.nDsoStop>0 & iVlv.nDsoStop<=sDso.iSize then
    iVlv.cStopSafe:= _fControl(iVlv.cStopSafe, dDso[iVlv.nDsoStop].sOn, dDso[iVlv.nDsoStop].fCh);
	iVlv.eDsoCmd   := iVlv.eDsoCmd or (dDso[iVlv.nDsoStop].sOn & iVlv.sError);                               (* Невыполнение команды (Безопасный режим) *)
	iVlv.fDsoStopOn:= dDso[iVlv.nDsoStop].sOn;									                             (* Воздействие ПАЗ активно. Стоп (Безопасный режим) *)
  end_if;
(* Открыть (Безопасный режим) *)
  If iVlv.nDsoOpen>0 & iVlv.nDsoOpen<=sDso.iSize then
    iVlv.cOpenSafe:= _fControl(iVlv.cOpenSafe, dDso[iVlv.nDsoOpen].sOn, dDso[iVlv.nDsoOpen].fCh);
	iVlv.eDsoCmd   := iVlv.eDsoCmd or (dDso[iVlv.nDsoOpen].sOn & iVlv.sError);                              (* Невыполнение команды (Безопасный режим) *)
	iVlv.fDsoOpenOn:= dDso[iVlv.nDsoOpen].sOn;									                            (* Воздействие ПАЗ активно. Открыть (Безопасный режим) *)
  end_if;
(* Закрыть (Безопасный режим) *)
  If iVlv.nDsoClose>0 & iVlv.nDsoClose<=sDso.iSize then
    iVlv.cCloseSafe:= _fControl(iVlv.cCloseSafe, dDso[iVlv.nDsoClose].sOn, dDso[iVlv.nDsoClose].fCh);
	iVlv.eDsoCmd    := iVlv.eDsoCmd or (dDso[iVlv.nDsoClose].sOn & iVlv.sError);                             (* Невыполнение команды (Безопасный режим) *)
	iVlv.fDsoCloseOn:= dDso[iVlv.nDsoClose].sOn;									                         (* Воздействие ПАЗ активно. Закрыть (Безопасный режим) *)
  end_if;
(* ---------------------------------------------------- *)
(* Команда режим РУЧНОЙ автоматически 
   - при аварийном управлении
   - при отсутствии режимов 
   - нет режимов при старте системы 
   - нет ремонтного режима *)
  iVlv.cHandleAuto:= iVlv.cHandleAuto or (iVlv.nMode & ((iVlv.cOpenSafe or iVlv.cCloseSafe or iVlv.cStopSafe) or 
                                                        (not (iVlv.rAuto or iVlv.rHandle or iVlv.rRepair)) or
                                                        (iVlv.nDist & not iVlv.sDist & not (iVlv.rHandle or iVlv.rRepair) & iVlv.fCh) or
                                                        (not iVlv.nRepair & iVlv.sError & iVlv.fCh)));    
(* ---------------------------------------------------------------*)
(* Команда режим РЕМОНТ *)
  iVlv.cRepair    := iVlv.cRepair     or (iVlv.nMode &  (iVlv.nRepair & iVlv.sError & iVlv.fCh));
(* ---------------------------------------------------- *)
(* Управление по Modbus *)  
  iVlv.sModbus:= (iVlv.sModbus or iVlv.cMbsCtrlOn) & not iVlv.cDioCtrlOn;
  iVlv.sIO    := not iVlv.sModbus;
  iVlv.yMbsOn := iVlv.sModbus;
  iVlv.yDOOn  := not iVlv.yMbsOn;
(* --------------------------------------------------------------- *)
(* Установка режимов *)
  iVlv.rAuto  := iVlv.nMode & (iVlv.rAuto   or iVlv.cAuto   or iVlv.cAutoAuto) & 
                 not iVlv.cHandle & not iVlv.cHandleAuto & not (iVlv.cRepair & iVlv.nRepair)    & not iVlv.sError;
  iVlv.rHandle:= iVlv.nMode & (iVlv.rHandle or iVlv.cHandle or iVlv.cHandleAuto) & 
                 not iVlv.cAuto   & not iVlv.cAutoAuto   & not (iVlv.cRepair & iVlv.nRepair)    & not iVlv.sError;
  iVlv.rRepair:= iVlv.nMode & (iVlv.rRepair or iVlv.cRepair  or iVlv.sError) & 
                 not iVlv.cAuto    & not iVlv.cHandle & iVlv.nRepair;
(* --------------------------------------------------------------- *)
(* Неисправность из дополнительного источника (ModBus/вспом. устройство) *)
  iVlv.sErrSrs:= iVlv.xErrSrs;
(* --------------------------------------------------------------- *)
(* Неисправность Общая *)
  iVlv.sError:= (iVlv.sError or  
     (iVlv.ePosition or   (* Неопределённое положение *)
      iVlv.eOpening  or   (* МП открытия не сработал *)
      iVlv.eClosing  or   (* МП закрытия не сработал *)
      iVlv.eStoping  or   (* Не выполнен Стоп *)
      iVlv.eOpen     or   (* Не сошла с КВ открытия *)
      iVlv.eClose    or   (* Не сошла с КВ закрытия *)
      iVlv.eOpenNot  or   (* Не открылась *)
      iVlv.eCloseNot or   (* Не закрылась *)
      iVlv.eyOpenFlt  or   (* Неисправна цепь Открытия *)
      iVlv.eyCloseFlt or   (* Неисправна цепь Закрытия *)
      iVlv.eErrMB    or   (* Сработал МВ *)
      iVlv.eExtErr   or   (* Неисправность схемы управления *)
      iVlv.sErrSrs)) &    (* Неисправность из дополнительного источника (ModBus/вспом. устройство) *)
	not iVlv.cDebl;
(* ---------------------------------------------------- *)
(* Возобновить действие после деблокировки неисправности при сработанной ПАЗ *)
(* Стоп (Безопасный режим) *)
  If iVlv.nDsoStop>0 & iVlv.nDsoStop<=sDso.iSize then
	iVlv.cStopSafe:= _fControl(iVlv.cStopSafe, dDso[iVlv.nDsoStop].sOn & iVlv.nESDErrDebl & not (iVlv.sError or iVlv.ePosition or iVlv.eOpening  or iVlv.eClosing or  
	                                                                                                            iVlv.eStoping  or iVlv.eOpen     or iVlv.eClose   or 
																												iVlv.eOpenNot  or iVlv.eCloseNot or iVlv.eyOpenFlt or 
																								                iVlv.eyCloseFlt or iVlv.eErrMB    or iVlv.eExtErr  or 
																												iVlv.sErrSrs),
											   iVlv.sError <> dVlv[i].sError);	
  end_if; 
(* Открыть (Безопасный режим) *)
  If iVlv.nDsoOpen>0 & iVlv.nDsoOpen<=sDso.iSize then
	iVlv.cOpenSafe:= _fControl(iVlv.cOpenSafe, dDso[iVlv.nDsoOpen].sOn & iVlv.nESDErrDebl & not (iVlv.sError or iVlv.ePosition or iVlv.eOpening  or iVlv.eClosing or  
	                                                                                                            iVlv.eStoping  or iVlv.eOpen     or iVlv.eClose   or 
																												iVlv.eOpenNot  or iVlv.eCloseNot or iVlv.eyOpenFlt or 
																								                iVlv.eyCloseFlt or iVlv.eErrMB    or iVlv.eExtErr  or 
																												iVlv.sErrSrs),
											   iVlv.sError <> dVlv[i].sError);	
  end_if;
(* Закрыть (Безопасный режим) *)
  If iVlv.nDsoClose>0 & iVlv.nDsoClose<=sDso.iSize then
	iVlv.cCloseSafe:= _fControl(iVlv.cCloseSafe, dDso[iVlv.nDsoClose].sOn & iVlv.nESDErrDebl & not (iVlv.sError or iVlv.ePosition or iVlv.eOpening  or iVlv.eClosing or  
	                                                                                                            iVlv.eStoping  or iVlv.eOpen     or iVlv.eClose   or 
																												iVlv.eOpenNot  or iVlv.eCloseNot or iVlv.eyOpenFlt or 
																								                iVlv.eyCloseFlt or iVlv.eErrMB    or iVlv.eExtErr  or 
																												iVlv.sErrSrs),
											   iVlv.sError <> dVlv[i].sError);	
  end_if;
(* Команда режим РУЧНОЙ автоматически *)
  iVlv.cHandleAuto:= iVlv.cHandleAuto or (iVlv.nMode & (iVlv.cOpenSafe or iVlv.cCloseSafe or iVlv.cStopSafe));  
(* --------------------------------------------------------------- *)
(* Авоматический останов при неисправности *)
(*2023.11.27 n.ils *)
  iVlv.cStopSafe:= _fControl(iVlv.cStopSafe,((iVlv.nStopMove & (iVlv.eOpening   or iVlv.eClosing))  or     (* Остановить при неисправности МП *)
                                             (iVlv.nStopPos  & (iVlv.eOpen      or iVlv.eClose))    or     (* Остановить при неисправности КВ *)
                                             (iVlv.nStopNot  & (iVlv.eOpenNot   or iVlv.eCloseNot)) or     (* Остановить при невыполнении полного хода *)
                                             (iVlv.nStopExt  &  iVlv.eExtErr)   or                         (* Остановить по внешней неисправности *)
                                                                iVlv.ePosition  or                         (* Неопределённое положение *)
                                                                iVlv.eyOpenFlt  or                         (* Неисправна цепь Открытия *)
                                                                iVlv.eyCloseFlt or                         (* Неисправна цепь Закрытия *)
                                                                iVlv.eErrMB     or                         (* Сработал МВ *)      
                                                                iVlv.sErrSrs),                             (* Неисправность из дополнительного источника (ModBus/вспом. устройство) *)
							    iVlv.sError <> dVlv[i].sError);	
 (* old m.alx *)
 (* iVlv.cStopSafe:= iVlv.cStopSafe or (not iVlv.sError &
                  ((iVlv.nStopMove & (iVlv.eOpening or iVlv.eClosing))  or     ( Остановить при неисправности МП )
                   (iVlv.nStopPos  & (iVlv.eOpen    or iVlv.eClose))    or     ( Остановить при неисправности КВ )
                   (iVlv.nStopNot  & (iVlv.eOpenNot or iVlv.eCloseNot)) or     ( Остановить при невыполнении полного хода )
                   (iVlv.nStopExt  &  iVlv.eExtErr)));                         ( Остановить по внешней неисправности *)
(* --------------------------------------------------------------- *)
(* Проверка готовности схемы (загорается при поступлении команды, висит до выполнения условий) *)
  if (iVlv.cOpenOper  or iVlv.cCloseOper    or iVlv.cStopOper or
    iVlv.cOpenAuto    or iVlv.cCloseAuto    or iVlv.cStopAuto or
    iVlv.cOpenOperPer or iVlv.cCloseOperPer or iVlv.mcNotWork) then
    iVlv.mcNotWork:= (iVlv.nPower & not iVlv.sPower) or (iVlv.nReady & not iVlv.sReady) or (iVlv.nDist & not iVlv.sDist);
  end_if;
(* --------------------------------------------------------------- *)
(* Блокировки управления *)
  iVlv.fOpenMsk:= iVlv.sOpen   or iVlv.sOpening  or iVlv.sError or
                  (iVlv.nPower & not iVlv.sPower)or
                  (iVlv.nDist  & not iVlv.sDist) or
                  (iVlv.nMode  & iVlv.rRepair)   or
                  (iVlv.nReady & not iVlv.sReady);
  iVlv.fCloseMsk:= iVlv.sClose or iVlv.sClosing or iVlv.sError or
                  (iVlv.nPower & not iVlv.sPower)or
                  (iVlv.nDist  & not iVlv.sDist) or
                  (iVlv.nMode  & iVlv.rRepair)   or
                  (iVlv.nReady & not iVlv.sReady);
  iVlv.fStopMsk:= (* (not iVlv.sOpening & not iVlv.sClosing & not iVlv.nLong & iVlv.tTimer1>0.0) or *)
                  (iVlv.nDist & not iVlv.sDist) or
                  (iVlv.nMode & iVlv.rRepair);
(* --------------------------------------------------------------- *)
(* Несоответствие режима *)
  iVlv.mcNotMode:= ((iVlv.rHandle or iVlv.nMode)     & (iVlv.cOpenAuto or iVlv.cCloseAuto   or iVlv.cStopAuto))or
                   ((iVlv.rRepair or iVlv.nMode)     & (iVlv.cOpenOper or iVlv.cCloseOper   or iVlv.cStopOper  or
                   iVlv.cOpenAuto or iVlv.cCloseAuto or iVlv.cStopAuto or iVlv.cOpenOperPer or iVlv.cCloseOperPer));
(* --------------------------------------------------------------- *)
(* Блокировки команд *)
  iVlv.cOpenOper    := iVlv.cOpenOper    & not iVlv.fOpenMsk;
  iVlv.cCloseOper   := iVlv.cCloseOper   & not iVlv.fCloseMsk;
  iVlv.cStopOper    := iVlv.cStopOper    & not iVlv.fStopMsk;
  iVlv.cOpenAuto    := iVlv.cOpenAuto    & not iVlv.fOpenMsk  & ((iVlv.nMode & iVlv.rAuto) or not iVlv.nMode);
  iVlv.cCloseAuto   := iVlv.cCloseAuto   & not iVlv.fCloseMsk & ((iVlv.nMode & iVlv.rAuto) or not iVlv.nMode);
  iVlv.cStopAuto    := iVlv.cStopAuto    & not iVlv.fStopMsk  & ((iVlv.nMode & iVlv.rAuto) or not iVlv.nMode);
(* --------------------------------------------------------------- *)
(* Есть поданная команда *)
  iVlv.fcStop := iVlv.cStopOper  or iVlv.cStopAuto  or iVlv.cStopSafe;
  iVlv.fcOpen := iVlv.cOpenOper  or iVlv.cOpenAuto  or iVlv.cOpenSafe  or iVlv.cOpenOperPer;
  iVlv.fcClose:= iVlv.cCloseOper or iVlv.cCloseAuto or iVlv.cCloseSafe or iVlv.cCloseOperPer;
(* Требуется авт. Открыть/Закрыть *)
  iVlv.fOpenTo := (iVlv.fOpenTo  or (iVlv.sClosing    & iVlv.fcOpen))  & not iVlv.lOpen  & not iVlv.sError; (* ...если закрывается и команда открыть и нет... *)
  iVlv.fCloseTo:= (iVlv.fCloseTo or (iVlv.sOpening    & iVlv.fcClose)) & not iVlv.lClose & not iVlv.sError; (* ...если открывается и команда закрыть и нет... *)
(* Перевод движения на противоположное *)
  if (iVlv.nLong & _tTimer(iVlv.tTimer1)=0.0 & (iVlv.fOpenTo or iVlv.fCloseTo)) then
    iVlv.lStop:= FALSE;
  end_if;
(* Работают команды *)
  iVlv.fcStop  :=  iVlv.fcStop   or (iVlv.sClosing & iVlv.fcOpen) or (iVlv.sOpening & iVlv.fcClose);
  iVlv.fcOpen  := (iVlv.fcOpen   & not iVlv.sClosing) or (not (iVlv.sOpening or iVlv.sClosing) & iVlv.fOpenTo  & not iVlv.lStop & not iVlv.fcStop); (* ...не открывается или не закрывается и авт. откр. и нет стопа... *)
  iVlv.fcClose := (iVlv.fcClose  & not iVlv.sOpening) or (not (iVlv.sOpening or iVlv.sClosing) & iVlv.fCloseTo & not iVlv.lStop & not iVlv.fcStop);
(* Обработка выходных команд *)
  iVlv.lStop := (iVlv.lStop  or iVlv.fcStop)  & not (iVlv.fcOpen or iVlv.fcClose);
  iVlv.lOpen := (iVlv.lOpen  or iVlv.fcOpen)  & not iVlv.fcStop & not iVlv.fcClose;
  iVlv.lClose:= (iVlv.lClose or iVlv.fcClose) & not iVlv.fcStop & not iVlv.fcOpen;
(* Подача выходных команд *)
  if    iVlv.nLong then (* ...непрерывные команды *)
    iVlv.lOpen := iVlv.lOpen  & ((_tTimer(iVlv.tTimer1)>0.0 & iVlv.mTimer1>0.0) or _tTimer(iVlv.tTimer1)=0.0 or iVlv.fcOpen);  if  iVlv.sOpen                 then iVlv.lOpen := false; end_if;     
    iVlv.lClose:= iVlv.lClose & ((_tTimer(iVlv.tTimer1)>0.0 & iVlv.mTimer1>0.0) or _tTimer(iVlv.tTimer1)=0.0 or iVlv.fcClose); if  iVlv.sClose                then iVlv.lClose:= false; end_if; 
    iVlv.lStop := iVlv.lStop  & ((_tTimer(iVlv.tTimer1)>0.0 & iVlv.mTimer1>0.0) or _tTimer(iVlv.tTimer1)=0.0 or iVlv.fcStop);  if (iVlv.sOpen or iVlv.sClose) then iVlv.lStop := false; end_if;
  elsif iVlv.nKeep then 
    iVlv.lOpen := iVlv.lOpen  & not (iVlv.lClose or iVlv.lStop);
    iVlv.lClose:= iVlv.lClose & not (iVlv.lOpen  or iVlv.lStop);
	iVlv.lStop := iVlv.lStop  & not (iVlv.lOpen  or iVlv.lClose);
  else
    iVlv.lOpen := iVlv.lOpen  & ((iVlv.nMoving & not iVlv.sOpening) or (not iVlv.nMoving & iVlv.mTimer1>0.0)) or iVlv.fcOpen;
    iVlv.lClose:= iVlv.lClose & ((iVlv.nMoving & not iVlv.sClosing) or (not iVlv.nMoving & iVlv.mTimer1>0.0)) or iVlv.fcClose;
    iVlv.lStop := iVlv.lStop  & ((iVlv.nMoving & (iVlv.sOpening     or iVlv.sClosing))   or (not iVlv.nMoving & iVlv.mTimer1>0.0)) or iVlv.fcStop;
  end_if;
(* ---------------------------------------------------- *)
(* Таймеры *)
  (* Т01 Срабатывание эл. цепей *)
  iVlv.mTimer1:= _fTimer(
         Start:= (not iVlv.nLong &  (iVlv.lOpen or iVlv.lClose or iVlv.lStop)) or
                 (    iVlv.nLong & ((iVlv.lOpen  & not iVlv.sOpening) or
                                    (iVlv.lClose & not iVlv.sClosing) or
                                    (iVlv.lStop  & (iVlv.sClosing or iVlv.sOpening)))),
          Stop:= (not iVlv.lOpen & not iVlv.lClose & not iVlv.lStop) or iVlv.sError,
        tTimer:= _tTimer(iVlv.tTimer1),
        mTimer:= iVlv.mTimer1);
        
  (* Т02 Время схода с КВ *)
  iVlv.mTimer2:= _fTimer(
         Start:= (iVlv.sOpen & iVlv.sClosing) or (iVlv.sClose & iVlv.sOpening),
          Stop:= _tTimer(iVlv.tTimer2)=0.0 or iVlv.sInter or iVlv.sError or 
		          (iVlv.sOpen & iVlv.sOpening) or (iVlv.sClose & iVlv.sClosing),
        tTimer:= _tTimer(iVlv.tTimer2),
        mTimer:= iVlv.mTimer2);
  
  (* Т03 Время выполнения полного открытия или закрытия *)
  iVlv.mTimer3:= _fTimer(
         Start:= (not iVlv.nKeep &
		          (iVlv.sClosing or iVlv.sOpening) or
                  (iVlv.nLong & _tTimer(iVlv.tTimer2)=0.0 & 
				   ((iVlv.lOpen  & not iVlv.sOpen) or 
				    (iVlv.lClose & not iVlv.sClose)))) or 
				 (iVlv.nKeep & (iVlv.lOpen   & not iVlv.sOpen) or (iVlv.lClose  & not iVlv.sClose))	,
          Stop:= _tTimer(iVlv.tTimer3)=0.0 or 
		         (not iVlv.nKeep & 
				  ((not iVlv.nLong & _tTimer(iVlv.tTimer2)>0.0 & not iVlv.sClosing & not iVlv.sOpening) or iVlv.lStop or iVlv.eOpenNot or iVlv.eCloseNot or
                   (    iVlv.nLong &                   
				   ((dVlv[i].lOpen  & iVlv.sOpen) or 
				    (dVlv[i].lClose & iVlv.sClose))))) or
                 (iVlv.nKeep & (iVlv.lOpen   & iVlv.sOpen) or (iVlv.lClose  & iVlv.sClose)) or 
				 iVlv.sError, 
       tTimer:= _tTimer(iVlv.tTimer3),
       mTimer:= iVlv.mTimer3);
    
  (* Т05 Таймер обработки неисправности неопр. положения *)
  iVlv.mTimer5:= _fTimer(
         Start:= iVlv.sOpen & iVlv.sClose,
          Stop:= (iVlv.sOpen & not iVlv.sClose) or (not iVlv.sOpen & iVlv.sClose) or iVlv.sInter or iVlv.ePosition,
        tTimer:= _tTimer(iVlv.tTimer1),
        mTimer:= iVlv.mTimer5);
    
  (* Т06 Таймер неисправности контроля цепей *)
  iVlv.mTimer6:= _fTimer(
         Start:= (iVlv.xOpenFlt & iVlv.nOpenFlt) or (iVlv.xCloseFlt & iVlv.nCloseFlt),
          Stop:= not(iVlv.xOpenFlt or iVlv.xCloseFlt), (* ...нет неисправности цепи открытия или закрытия *)
        tTimer:= _tTimer(iVlv.tTimer1),
        mTimer:= iVlv.mTimer6);
  (* Т09 Таймер удержания деблокировки yDebl *)
  iVlv.mTimer9:= _fTimer(
         Start:= iVlv.cDebl,
          Stop:= false,
        tTimer:= 1.0,
        mTimer:= iVlv.mTimer9);		
  (* ---------------------------------------------------- *)
  (* Неисправность *)
  iVlv.ePosition:= (iVlv.sOpen & iVlv.sClose        & iVlv.mTimer5=-1.0) or
                   (iVlv.ePosition  & iVlv.sError);                                      (* Неопределённое положение *)
  iVlv.eOpening := (iVlv.nMoving & iVlv.lOpen       & iVlv.mTimer1=-1.0 & _tTimer(iVlv.tTimer1)>0.0) or
                   (iVlv.eOpening & iVlv.sError);                                         (* МП открытия не сработал *)
  iVlv.eClosing := (iVlv.nMoving      & iVlv.lClose & iVlv.mTimer1=-1.0 & _tTimer(iVlv.tTimer1)>0.0) or 
                   (iVlv.eClosing & iVlv.sError);                                         (* МП закрытия не сработал *)
  iVlv.eStoping := (iVlv.nMoving      & iVlv.lStop  & iVlv.mTimer1=-1.0 & _tTimer(iVlv.tTimer1)>0.0) or
                   (iVlv.eStoping & iVlv.sError);                                         (* Не выполнен Стоп *)
  iVlv.eOpen    := (iVlv.sOpen                      & iVlv.mTimer2=-1.0 & _tTimer(iVlv.tTimer2)>0.0) or 
                   (iVlv.eOpen       & iVlv.sError);                                      (* Не сошла с КВ открытия *)
  iVlv.eClose   := (iVlv.sClose                     & iVlv.mTimer2=-1.0 & _tTimer(iVlv.tTimer2)>0.0) or 
                   (iVlv.eClose      & iVlv.sError);                                      (* Не сошла с КВ закрытия *)
  iVlv.eOpenNot := (iVlv.mTimer3=-1.0 & _tTimer(iVlv.tTimer3)>0.0 & iVlv.sOpening)  or
                   (iVlv.eOpenNot   & iVlv.sError);                                       (* Не открылась *)
  iVlv.eCloseNot:= (iVlv.mTimer3=-1.0 & _tTimer(iVlv.tTimer3)>0.0 & iVlv.sClosing) or
                   (iVlv.eCloseNot  & iVlv.sError);                                       (* Не закрылаcь *)
  iVlv.eyOpenFlt := (iVlv.mTimer6=-1.0 & iVlv.xOpenFlt) or
                   (iVlv.eyOpenFlt    & iVlv.sError);                                      (* Неисправна цепь Открытия *)
  iVlv.eyCloseFlt:= (iVlv.mTimer6=-1.0 & iVlv.xCloseFlt) or
                   (iVlv.eyCloseFlt   & iVlv.sError);                                      (* Неисправна цепь Закрытия *)
  iVlv.eExtErr  := (iVlv.xExtErr      & iVlv.nExtErr) or
                   (iVlv.eExtErr     & iVlv.sError);                                      (* Неисправность схемы управления *)
  iVlv.eErrMB   := (iVlv.xErrMB)      or(iVlv.eErrMB      & iVlv.sError);                 (* Сработал МВ (Моментный Выключатель) *)
  (* ---------------------------------------------------- *)
  (* Процент открытия - расчёт *)
  (*
  // iVlv.mTimerFull - REAL последнее времени хода
  // iVlv.Percent    - REAL расчётный процент
  // iVlv.tTimer3    - REAL время выполнения полного открытия или закрытия
  // iVlv.mTimer7    - DINT текущее положение во времени
  // iVlv.nAnaPercent- DINT номер объекта
  *)  
  (* ---------------------------------------------------- *)
  (* Изменилось состояние                              //...??? будет ли успивать считываться ВУ *)
  iVlv.fCh:= (iVlv.sInter   <> dVlv[i].sInter)
          or (iVlv.sOpen    <> dVlv[i].sOpen)
          or (iVlv.sClose   <> dVlv[i].sClose)
          or (iVlv.sOpening <> dVlv[i].sOpening)
          or (iVlv.sClosing <> dVlv[i].sClosing);
  (* ---------------------------------------------------- *)
  (* Команды без имитации *)
  if not iVlv.sImit then
    iVlv.yOpen := iVlv.lOpen;
    iVlv.yClose:= iVlv.lClose;
    iVlv.yStop := iVlv.lStop;
    iVlv.yDist := iVlv.lDist;
	iVlv.yDebl := iVlv.mTimer9>0.0;
  end_if;
  (* ---------------------------------------------------- *)
  (* Команды в местном режиме управления *)
  if iVlv.nDist & not iVlv.sDist then
    iVlv.yOpen := false;
    iVlv.yClose:= false;
    iVlv.yStop := false;
  end_if;
  (* --------------------------------------------------------------- *)
  (* Снятие команд, входов и обнуление таймеров при выводе из имитации *)
  if (iVlv.cImitOff & not iVlv.sImit) then
    iVlv.xOpen   := false;
    iVlv.xClose  := false;
    iVlv.xOpening:= false;
    iVlv.xClosing:= false;
    iVlv.lOpen   := false;
    iVlv.lClose  := false;
    iVlv.lStop   := false;
    iVlv.lDist   := false;
    iVlv.mTimer1 := 0.0;
    iVlv.mTimer2 := 0.0;
    iVlv.mTimer3 := 0.0;
  end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Конец логики *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сохраняемые переменные (сохранение данных) *)
  rVlv[i].rAuto         :=   iVlv.rAuto;                         (* Режим Автомат *) 
  rVlv[i].rHandle       :=   iVlv.rHandle;                       (* Режим Ручной *)  
  rVlv[i].rRepair       :=   iVlv.rRepair;                       (* Режим Ремонт *)  
  rVlv[i].sImit         :=   iVlv.sImit;                         (* Имитация *)      
  rVlv[i].sDist         :=   iVlv.sDist;                         (* Управление Дистанционное *)
  rVlv[i].sError        :=   iVlv.sError;                        (* Общая неисправность *)
  rVlv[i].sModbus       :=   iVlv.sModbus;                       (* Управление по Modbus *)
  rVlv[i].lOpen         :=   iVlv.lOpen;                         (* Открыть (внутр.) *)
  rVlv[i].lClose        :=   iVlv.lClose;                        (* Закрыть (внутр.) *)
  rVlv[i].lStop         :=   iVlv.lStop;                         (* Стоп (внутр.) *) 
  rVlv[i].lDist         :=   iVlv.lDist;                         (* Дист. управление (внутр.) *)
  rVlv[i].xErrOpenR     :=   iVlv.xErrOpenR;                     (* КВ открытия (Резерв). Неисправность канала *)
  rVlv[i].xErrCloseR    :=   iVlv.xErrCloseR;                    (* КВ закрытия (Резерв). Неисправность канала *)
  rVlv[i].yOpen         :=   iVlv.yOpen;                         (* Открыть *)       
  rVlv[i].yClose        :=   iVlv.yClose;                        (* Закрыть *)       
  rVlv[i].yStop         :=   iVlv.yStop;                         (* Стоп *)          
  rVlv[i].yDist         :=   iVlv.yDist;                         (* Включить Управление Дистанционное *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Упаковка сообщений для команд *)
  iVlv.Command.0        := iVlv.cImitOn;                         (* Команда оператора. Включить имитацию *)
  iVlv.Command.1        := iVlv.cImitOff;                        (* Команда оператора. Отключить имитацию *)
  iVlv.Command.2        := iVlv.cDistOn;                         (* Команда оператора. Включить режим Дист. управления *)
  iVlv.Command.3        := iVlv.cDistOff;                        (* Команда оператора. Отключить режим Дист. управления *)
  iVlv.Command.4        := iVlv.cDebl;                           (* Деблокировать неисправность *)
  iVlv.Command.5        := iVlv.cAuto;                           (* Команда оператора. Режим Автомат *)
  iVlv.Command.6        := iVlv.cHandle;                         (* Команда оператора. Режим Ручной *)
  iVlv.Command.7        := iVlv.cRepair;                         (* Команда оператора. Режим Ремонт *)
  iVlv.Command.10       := iVlv.cOpenOper;                       (* Команда оператора. Открыть *)
  iVlv.Command.11       := iVlv.cCloseOper;                      (* Команда оператора. Закрыть *)
  iVlv.Command.12       := iVlv.cStopOper;                       (* Команда оператора. Стоп *)
  iVlv.Command.13       := iVlv.cOpenAuto;                       (* Команда Автоматическая. Открыть *)
  iVlv.Command.14       := iVlv.cCloseAuto;                      (* Команда Автоматическая. Закрыть *)
  iVlv.Command.15       := iVlv.cStopAuto;                       (* Команда Автоматическая. Стоп *)
  iVlv.Command.16       := iVlv.cOpenOperPer;                    (* Команда оператора. Открыть на % *)
  iVlv.Command.17       := iVlv.cCloseOperPer;                   (* Команда оператора. Закрыть на % *)
  iVlv.Command.18       := iVlv.cOpenSafe;                       (* Команда Открыть (Безопасный Режим) *)
  iVlv.Command.19       := iVlv.cCloseSafe;                      (* Команда Закрыть (Безопасный Режим) *)
  iVlv.Command.20       := iVlv.cStopSafe;                       (* Команда Стоп (Безопасный Режим) *)
  iVlv.Command.21       := iVlv.cMbsCtrlOn;                      (* Команда оператора. Включить управление по ModBus *)
  iVlv.Command.22       := iVlv.cDioCtrlOn;                      (* Команда оператора. Включить управление по физ. сигналам *)
  iVlv.Command.23       := iVlv.cAutoAuto;                       (* Команда Автоматическая. Режим Автомат *)
  iVlv.Command.24       := iVlv.cHandleAuto;                     (* Команда Автоматическая. Режим Ручной *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Cообщения для команд *)
  if iVlv.MsAck_State >iVlv.oMsAck_State then iVlv.MsEvt_Command:= 0;                  end_if;
  if iVlv.Command    <>0                 then iVlv.MsEvt_Command:= iVlv.Command;       end_if;
  iVlv.oMsAck_State:= iVlv.MsAck_State;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сброс команд *)
  iVlv.Command:= 0;
  iVlv.cImitOn          := false;                                (* Команда оператора. Включить имитацию *)
  iVlv.cImitOff         := false;                                (* Команда оператора. Отключить имитацию *)
  iVlv.cDistOn          := false;                                (* Команда оператора. Включить режим Дист. управления *)
  iVlv.cDistOff         := false;                                (* Команда оператора. Отключить режим Дист. управления *)
  iVlv.cDebl            := false;                                (* Деблокировать неисправность *)
  iVlv.cAuto            := false;                                (* Команда оператора. Режим Автомат *)
  iVlv.cHandle          := false;                                (* Команда оператора. Режим Ручной *)
  iVlv.cRepair          := false;                                (* Команда оператора. Режим Ремонт *)
  iVlv.cOpenOper        := false;                                (* Команда оператора. Открыть *)
  iVlv.cCloseOper       := false;                                (* Команда оператора. Закрыть *)
  iVlv.cStopOper        := false;                                (* Команда оператора. Стоп *)
  iVlv.cOpenAuto        := false;                                (* Команда Автоматическая. Открыть *)
  iVlv.cCloseAuto       := false;                                (* Команда Автоматическая. Закрыть *)
  iVlv.cStopAuto        := false;                                (* Команда Автоматическая. Стоп *)
  iVlv.cOpenOperPer     := false;                                (* Команда оператора. Открыть на % *)
  iVlv.cCloseOperPer    := false;                                (* Команда оператора. Закрыть на % *)
  iVlv.cOpenSafe        := false;                                (* Команда Открыть (Безопасный Режим) *)
  iVlv.cCloseSafe       := false;                                (* Команда Закрыть (Безопасный Режим) *)
  iVlv.cStopSafe        := false;                                (* Команда Стоп (Безопасный Режим) *)
  iVlv.cMbsCtrlOn       := false;                                (* Команда оператора. Включить управление по ModBus *)
  iVlv.cDioCtrlOn       := false;                                (* Команда оператора. Включить управление по физ. сигналам *)
  iVlv.cAutoAuto        := false;                                (* Команда Автоматическая. Режим Автомат *)
  iVlv.cHandleAuto      := false;                                (* Команда Автоматическая. Режим Ручной *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Передача из Рабочего объекта *)
  dVlv[i]:= iVlv;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Отключение резевных объектов *)
end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Отключение резервных объектов: Сброс состояния объекта *)
if dVlv[i].nLogicNot & not dVlv[i].oLogicNot then
  dVlv[i].sOpen         := false;                                (* Открыт(а) *)     
  dVlv[i].sClose        := false;                                (* Закрыт(а) *)     
  dVlv[i].sInter        := false;                                (* Промеж. положение *)
  dVlv[i].sOpening      := false;                                (* Открывается *)   
  dVlv[i].sClosing      := false;                                (* Закрывается *)   
  dVlv[i].sImit         := false;                                (* Имитация *)      
  dVlv[i].sDist         := false;                                (* Управление Дистанционное *)
  dVlv[i].sLocal        := false;                                (* Управление Местное *)
  dVlv[i].sNo           := false;                                (* Управление Отключено *)
  dVlv[i].sNotPower     := false;                                (* Нет напряжения в схеме управления *)
  dVlv[i].sNotReady     := false;                                (* Не готов к управлению *)
  dVlv[i].sError        := false;                                (* Общая неисправность *)
  dVlv[i].sPower        := false;                                (* Есть напряжение в схеме управления *)
  dVlv[i].sReady        := false;                                (* Готов к управлению *)
  dVlv[i].sIO           := false;                                (* Управление по Каналам ввода-вывода *)
  dVlv[i].sNotModbus    := false;                                (* Нет связи по интерфейсу Modbus *)
  dVlv[i].sModbus       := false;                                (* Управление по Modbus *)
(* maskStateNone=2013298463 *)
end_if;
dVlv[i].oLogicNot:= dVlv[i].nLogicNot;
(* ------------------------------------------------------------------------------------------------------------------ *)
i:= i+1;end_while;
END_FUNCTION