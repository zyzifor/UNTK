FUNCTION processAna
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Name            Data Type      Dimension            Direction  Attribute       Comment                             *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* processAna     DINT                                VarOutput  Write           Результат выполнения функции *)
(* iAna            typAna                              Var        Read/Write      Рабочий объект *)
(* i               DINT                                Var        Read/Write      Счётчик *)
(* _bRes           BOOL                                Var        Read/Write      Результат функции BOOL *)
(* _dRes           DINT                                Var        Read/Write      Результат функции DINT *)
(* ------------------------------------------------------------------------------------------------------------------ *)
processAna:= sAna.iSize;
if sAna.iSize>sAna.iMax then processAna:= -sAna.iSize; return; end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Проход по всем параметрам *)
i:= 1;   while i<=sAna.iSize do
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Отключение резевных объектов *)
if not dAna[i].nLogicNot then
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Передача в Рабочий объект *)
  iAna:= dAna[i];
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сохраняемые переменные (чтение при первом скане) *)
  if iPrgModify then
    iAna.Value          := rAna[i].Value;                        (* Значение *)      
    iAna.sMask          := rAna[i].sMask;                        (* Маскирование установлено *)
    iAna.sImit          := rAna[i].sImit;                        (* Имитация установлена *)
  end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Начало логики *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Имитация *)    
  iAna.sImit:= (iAna.sImit or iAna.cImitOn) & not iAna.cImitOff;
(* Состояние неисправности, при включении имитации *)  
  if iAna.sImit & iAna.cImitOn then 
    if iAna.sHLm   then iAna.Value:= iAna.tHLm+ABS(iAna.tHLm-iAna.tLLm)*0.01; end_if;
    if iAna.sLLm   then iAna.Value:= iAna.tLLm-ABS(iAna.tHLm-iAna.tLLm)*0.01; end_if;
	if iAna.sError then iAna.Value:= iAna.tLLm-ABS(iAna.tHLm-iAna.tLLm)*0.01; end_if;
  end_if; 
(* Маскирование *)    
  iAna.sMask:= (iAna.sMask or iAna.cMaskOn) & not iAna.cMaskOff;
(* Проверка корректности уставок *)
  if ((iAna.tHH1>iAna.tHLm & iAna.tHLm>iAna.tLLm) or
      (iAna.tHH1<iAna.tLLm & iAna.tHLm<iAna.tLLm)) & iAna.sEnableHH1                  then iAna.tHH1:= iAna.tHLm; end_if;
  if ((iAna.tHH >iAna.tHH1 & iAna.tHLm>iAna.tLLm) or
      (iAna.tHH <iAna.tHH1 & iAna.tHLm<iAna.tLLm)) & iAna.sEnableHH & iAna.sEnableHH1 then iAna.tHH := iAna.tHH1; end_if;
  if ((iAna.tH1 >iAna.tHH  & iAna.tHLm>iAna.tLLm) or
      (iAna.tH1 <iAna.tHH  & iAna.tHLm<iAna.tLLm)) & iAna.sEnableH1 & iAna.sEnableHH  then iAna.tH1 := iAna.tHH;  end_if;
  if ((iAna.tH  >iAna.tH1  & iAna.tHLm>iAna.tLLm) or
      (iAna.tH  <iAna.tH1  & iAna.tHLm<iAna.tLLm)) & iAna.sEnableH  & iAna.sEnableH1  then iAna.tH  := iAna.tH1;  end_if;
  if ((iAna.tL  <iAna.tL1  & iAna.tHLm>iAna.tLLm) or
      (iAna.tL  >iAna.tL1  & iAna.tHLm<iAna.tLLm)) & iAna.sEnableL  & iAna.sEnableL1  then iAna.tL  := iAna.tL1;  end_if;
  if ((iAna.tL1 <iAna.tLL  & iAna.tHLm>iAna.tLLm) or
      (iAna.tL1 >iAna.tLL  & iAna.tHLm<iAna.tLLm)) & iAna.sEnableL1 & iAna.sEnableLL  then iAna.tL1 := iAna.tLL;  end_if;
  if ((iAna.tLL <iAna.tLL1 & iAna.tHLm>iAna.tLLm) or
      (iAna.tLL >iAna.tLL1 & iAna.tHLm<iAna.tLLm)) & iAna.sEnableLL & iAna.sEnableLL1 then iAna.tLL := iAna.tLL1; end_if;
  if ((iAna.tLL1<iAna.tLLm & iAna.tHLm>iAna.tLLm) or
      (iAna.tLL1>iAna.tHLm & iAna.tHLm<iAna.tLLm)) & iAna.sEnableLL1                  then iAna.tLL1:= iAna.tLLm; end_if;
(* ---------------------------------------------------------------*)
(* Обработка состояний *)    
(* Неисправность оборудования*)
  if not iAna.nCurrR then
    iAna.sError:= iAna.xError & not iAna.sImit & not iAna.sMask;     
  else 
(* Используется Резервирование каналов *)
(* ---------------------------------------------- *)
  (* Рассогласование каналов *)
    if iAna.tCurrHi<>iAna.tCurrLow then                                                  (* защита от деления на 0 *)
      iAna.mCurrDiff:= ANY_TO_WORD(ABS(ANY_TO_REAL(ANY_TO_DINT(iAna.xCurr)  -ANY_TO_DINT(iAna.xCurrR)))/
                                   ABS(ANY_TO_REAL(ANY_TO_DINT(iAna.tCurrHi)-ANY_TO_DINT(iAna.tCurrLow)))*1000.0);   
    end_if;
    (*iAna.mTimer11:= _fTimer(Start := iAna.mCurrDiff>iAna.tCurrDiff & not iAna.eCurrDiff, 
                            Stop  := not(iAna.mCurrDiff>iAna.tCurrDiff),
                            tTimer:= ANY_TO_REAL(iAna.tTimer11)*0.1,
                            mTimer:= iAna.mTimer11);
	  						
    iAna.eCurrDiff:= (iAna.mCurrDiff>iAna.tCurrDiff) & iAna.mTimer11=0.0;*)
	(* Раcсогласование каналов резервирования*)
    iAna.eCurrDiff:= iAna.mCurrDiff>iAna.tCurrDiff & not iAna.sImit &
	                 ANY_TO_DINT(iAna.xCurr)<ANY_TO_DINT(iAna.tCurrLow)-ANY_TO_DINT(iAna.tCurrExt) &
					 ANY_TO_DINT(iAna.xCurrR)<ANY_TO_DINT(iAna.tCurrLow)-ANY_TO_DINT(iAna.tCurrExt) &
					 ANY_TO_DINT(iAna.xCurr)>ANY_TO_DINT(iAna.tCurrHi) +ANY_TO_DINT(iAna.tCurrExt) &
					 ANY_TO_DINT(iAna.xCurrR)>ANY_TO_DINT(iAna.tCurrHi) +ANY_TO_DINT(iAna.tCurrExt);
	iAna.mTimer11:= _fTimer(Start := iAna.eCurrDiff & not dAna[i].eCurrDiff, 
                            Stop  := not(iAna.eCurrDiff & not dAna[i].eCurrDiff),
                            tTimer := _tTimer(iAna.tTimer11),
                            mTimer := iAna.mTimer11);
    (* Срабатывание по таймеру *) 
    if iAna.mTimer11>0.0 then
      iAna.eCurrDiff:= dAna[i].eCurrDiff;
	end_if;
(* ---------------------------------------------- *)
    iAna.eCurrM := iAna.xError  & not iAna.sImit & not iAna.sMask;  
    iAna.eCurrR := iAna.xErrorR & not iAna.sImit & not iAna.sMask;  
    iAna.sError := iAna.eCurrM & iAna.eCurrR;
  end_if;
  iAna.sOkCurrM:= not iAna.nCurrR or
                  (iAna.nCurrR & not iAna.eCurrM & 
                   ANY_TO_DINT(iAna.xCurr)>=ANY_TO_DINT(iAna.tCurrLow)-ANY_TO_DINT(iAna.tCurrExt) &
				   ANY_TO_DINT(iAna.xCurr)<=ANY_TO_DINT(iAna.tCurrHi) +ANY_TO_DINT(iAna.tCurrExt));	        (* Активен канал Основной *)
  iAna.sOkCurrR:= iAna.eCurrM or
                  (iAna.nCurrR & not iAna.eCurrR & not iAna.sOkCurrM &
                   ANY_TO_DINT(iAna.xCurrR)>=ANY_TO_DINT(iAna.tCurrLow)-ANY_TO_DINT(iAna.tCurrExt) &
				   ANY_TO_DINT(iAna.xCurrR)<=ANY_TO_DINT(iAna.tCurrHi) +ANY_TO_DINT(iAna.tCurrExt));	     (* Активен канал Резервный *)
 (* берём ток активного канала *)
  iAna.lCurr:= iAna.xCurrR;
  if iAna.sOkCurrM then iAna.lCurr:= iAna.xCurr; end_if;                                        
(* Ниже и Выше шкалы датчика *)
  if iAna.tCurrLow<>iAna.tCurrHi then
    if not iAna.sMask then
      iAna.sLLm:= (not iAna.sImit & ANY_TO_DINT(iAna.lCurr)<ANY_TO_DINT(iAna.tCurrLow)-ANY_TO_DINT(iAna.tCurrExt)) or 
                  (iAna.sImit     & ((iAna.Value<iAna.tLLm & iAna.tHLm>iAna.tLLm) or (iAna.Value>iAna.tLLm & iAna.tHLm<iAna.tLLm)));
      iAna.sLLm:= iAna.sLLm & not iAna.sError;
      iAna.sHLm:= (not iAna.sImit & ANY_TO_DINT(iAna.lCurr)>ANY_TO_DINT(iAna.tCurrHi) +ANY_TO_DINT(iAna.tCurrExt)) or 
                  (iAna.sImit     & ((iAna.Value>iAna.tHLm & iAna.tHLm>iAna.tLLm) or (iAna.Value<iAna.tHLm & iAna.tHLm<iAna.tLLm)));
      iAna.sHLm:= iAna.sHLm & not iAna.sError;
    end_if;

(* Масштабирование *)
    if  not iAna.sImit then
      if not iAna.sLLm & not iAna.sHLm & iAna.tHLm<>iAna.tLLm & iAna.tCurrHi<>iAna.tCurrLow then              
        iAna.Value:= ANY_TO_REAL(ANY_TO_DINT(iAna.lCurr)-ANY_TO_DINT(iAna.tCurrLow))/
                     ANY_TO_REAL(iAna.tCurrHi-iAna.tCurrLow)*(iAna.tHLm-iAna.tLLm)+iAna.tLLm;
      end_if;
      if iAna.sLLm or ((iAna.Value<=iAna.tLLm & iAna.tHLm>iAna.tLLm) or (iAna.Value>=iAna.tLLm & iAna.tHLm<iAna.tLLm)) then 
        iAna.Value:= iAna.tLLm;
      end_if;
      if iAna.sHLm or ((iAna.Value>=iAna.tHLm & iAna.tHLm>iAna.tLLm) or (iAna.Value<=iAna.tHLm & iAna.tHLm<iAna.tLLm)) then 
        iAna.Value:= iAna.tHLm;
      end_if;
    end_if;
  else
    if not iAna.sImit then
	  iAna.Value:= iAna.xValue;
    end_if;	
    if not iAna.sMask then
      if iAna.tHLm>iAna.tLLm then 
        iAna.sHLm:= iAna.Value>=iAna.tHLm or (iAna.Value>=iAna.tHLm-iAna.tHist & iAna.sHLm);    
        iAna.sLLm:= iAna.Value<=iAna.tLLm or (iAna.Value<=iAna.tLLm+iAna.tHist & iAna.sLLm);
      end_if; 
      if iAna.tHLm<iAna.tLLm then 
        iAna.sHLm:= iAna.Value<=iAna.tHLm or (iAna.Value<=iAna.tHLm+iAna.tHist & iAna.sHLm);    
        iAna.sLLm:= iAna.Value>=iAna.tLLm or (iAna.Value>=iAna.tLLm-iAna.tHist & iAna.sLLm);
      end_if; 
    end_if; 
  end_if;
(* Включение уставок *)
  iAna.sEnableHH1:= iAna.tEnableSet.5;  (* Включена в работу Уставка Верхний Аварийный (HH1) *)
  iAna.sEnableHH := iAna.tEnableSet.6;  (* Включена в работу Уставка Вехнний Аварийный (HH) *)
  iAna.sEnableH1 := iAna.tEnableSet.7;  (* Включена в работу Уставка Верхний Предупредительный (H1) *)
  iAna.sEnableH  := iAna.tEnableSet.8;  (* Включена в работу Уставка Верхний Предупредительный (H) *)
  iAna.sEnableL  := iAna.tEnableSet.9;  (* Включена в работу Уставка Нижний Предупредительный (L) *)
  iAna.sEnableL1 := iAna.tEnableSet.10; (* Включена в работу Уставка Нижний Предупредительный (L1) *)
  iAna.sEnableLL := iAna.tEnableSet.11; (* Включена в работу Уставка Нижний Аварийный (LL) *)
  iAna.sEnableLL1:= iAna.tEnableSet.12; (* Включена в работу Уставка Нижний Аварийный (LL1) *)
(* Сравнение с уставками *)
  if not iAna.sHLm & not iAna.sLLm & not iAna.sError & not iAna.sMask then
    if iAna.tHLm>iAna.tLLm then 
      iAna.sHH1:= (iAna.Value>=iAna.tHH1 or (iAna.Value>=iAna.tHH1-iAna.tHist & iAna.sHH1)) &
                  (iAna.tHLm<>iAna.tHH1) & iAna.sEnableHH1;    
      iAna.sHH := (iAna.Value>=iAna.tHH  or (iAna.Value>=iAna.tHH -iAna.tHist & iAna.sHH )) &
                  (iAna.tHH1<>iAna.tHH or not iAna.sEnableHH1)  & iAna.sEnableHH ;    
      iAna.sH1 := (iAna.Value>=iAna.tH1  or (iAna.Value>=iAna.tH1 -iAna.tHist & iAna.sH1)) &
                  (iAna.tHH <>iAna.tH1 or not iAna.sEnableHH)   & iAna.sEnableH1;    
      iAna.sH  := (iAna.Value>=iAna.tH   or (iAna.Value>=iAna.tH  -iAna.tHist & iAna.sH )) &
                  (iAna.tH1 <>iAna.tH  or not iAna.sEnableH1)   & iAna.sEnableH;    
      iAna.sL  := (iAna.Value<=iAna.tL   or (iAna.Value<=iAna.tL  +iAna.tHist & iAna.sL )) &
                  (iAna.tL1<>iAna.tL   or not iAna.sEnableL1)   & iAna.sEnableL;    
      iAna.sL1 := (iAna.Value<=iAna.tL1  or (iAna.Value<=iAna.tL1 +iAna.tHist & iAna.sL1 )) &
                  (iAna.tLL<>iAna.tL1  or not iAna.sEnableLL)   & iAna.sEnableL1;    
      iAna.sLL := (iAna.Value<=iAna.tLL  or (iAna.Value<=iAna.tLL +iAna.tHist & iAna.sLL )) &
                  (iAna.tLL1<>iAna.tLL or not iAna.sEnableLL1) & iAna.sEnableLL;    
      iAna.sLL1:= (iAna.Value<=iAna.tLL1 or (iAna.Value<=iAna.tLL1+iAna.tHist & iAna.sLL1)) &
                  (iAna.tLLm<>iAna.tLL1) & iAna.sEnableLL1;
    end_if; 
    if iAna.tHLm<iAna.tLLm then 
      iAna.sHH1:= (iAna.Value<=iAna.tHH1 or (iAna.Value<=iAna.tHH1+iAna.tHist & iAna.sHH1)) &
                  (iAna.tHLm<>iAna.tHH1) & iAna.sEnableHH1;    
      iAna.sHH := (iAna.Value<=iAna.tHH  or (iAna.Value<=iAna.tHH +iAna.tHist & iAna.sHH)) &
                  (iAna.tHH1<>iAna.tHH or not iAna.sEnableHH1)  & iAna.sEnableHH;    
      iAna.sH1 := (iAna.Value<=iAna.tH1  or (iAna.Value<=iAna.tH1 +iAna.tHist & iAna.sH1)) &
                  (iAna.tHH<>iAna.tH1  or not iAna.sEnableHH)   & iAna.sEnableH1;    
      iAna.sH  := (iAna.Value<=iAna.tH   or (iAna.Value<=iAna.tH  +iAna.tHist & iAna.sH)) &
                  (iAna.tH1<>iAna.tH   or not iAna.sEnableH1)   & iAna.sEnableH;    
      iAna.sL  := (iAna.Value>=iAna.tL   or (iAna.Value>=iAna.tL  -iAna.tHist & iAna.sL)) &
                  (iAna.tL1<>iAna.tL   or not iAna.sEnableL1)   & iAna.sEnableL;    
      iAna.sL1 := (iAna.Value>=iAna.tL1  or (iAna.Value>=iAna.tL1 -iAna.tHist & iAna.sL1)) &
                  (iAna.tLL<>iAna.tL1  or not iAna.sEnableLL)   & iAna.sEnableL1;    
      iAna.sLL := (iAna.Value>=iAna.tLL  or (iAna.Value>=iAna.tLL -iAna.tHist & iAna.sLL)) &
                  (iAna.tLL1>iAna.tLL  or not iAna.sEnableLL1)  & iAna.sEnableLL;    
      iAna.sLL1:= (iAna.Value>=iAna.tLL1 or (iAna.Value>=iAna.tLL1-iAna.tHist & iAna.sLL1)) &
                  (iAna.tLLm<>iAna.tLL1) & iAna.sEnableLL1;
    end_if; 
  else 
	iAna.sHH1:= false;
    iAna.sHH := false;
	iAna.sH1 := false;
	iAna.sH  := false;
	iAna.sL  := false;
	iAna.sL1 := false;
	iAna.sLL := false;
	iAna.sLL1:= false;
  end_if;
(* Фильтрация дребезга срабатывания уставок параметра по времени*)
  iAna.mTimer1:= _fTimer(
    Start  := ((iAna.sH   & not dAna[i].sH)   or (iAna.sL   & not dAna[i].sL)  or 
	           (iAna.sH1  & not dAna[i].sH1)  or (iAna.sL1  & not dAna[i].sL1) or 
	           (iAna.sHH  & not dAna[i].sHH)  or (iAna.sLL  & not dAna[i].sLL) or 
			   (iAna.sHH1 & not dAna[i].sHH1) or (iAna.sLL1 & not dAna[i].sLL1)), 
    Stop   := not ((iAna.sH   & not dAna[i].sH)   or (iAna.sL   & not dAna[i].sL)  or
                   (iAna.sH1  & not dAna[i].sH1)  or (iAna.sL1  & not dAna[i].sL1) or 
                   (iAna.sHH  & not dAna[i].sHH)  or (iAna.sLL  & not dAna[i].sLL) or 
				   (iAna.sHH1 & not dAna[i].sHH1) or (iAna.sLL1 & not dAna[i].sLL1)),
    tTimer := _tTimer(iAna.tTimer1),
    mTimer := iAna.mTimer1);
(* Снятие по маскированию *)
  iAna.sHH1:= iAna.sHH1 & not iAna.sMask;
  iAna.sHH := iAna.sHH  & not iAna.sMask;
  iAna.sH1 := iAna.sH1  & not iAna.sMask;
  iAna.sH  := iAna.sH   & not iAna.sMask;
  iAna.sL  := iAna.sL   & not iAna.sMask;
  iAna.sLL := iAna.sLL  & not iAna.sMask;
  iAna.sL1 := iAna.sL1  & not iAna.sMask;
  iAna.sLL1:= iAna.sLL1 & not iAna.sMask;
(* В норме*)
  iAna.sOk:=  not iAna.sHLm & not iAna.sHH1 & not iAna.sHH & not iAna.sH1 & not iAna.sH & 
              not iAna.sLLm & not iAna.sLL1 & not iAna.sLL & not iAna.sL1 & not iAna.sL &  
			  not iAna.sError;
(* Изменилость состояние*)
  iAna.fCh:= (iAna.sHLm  <>dAna[i].sHLm) or 
             (iAna.sHH1  <>dAna[i].sHH1) or
             (iAna.sHH   <>dAna[i].sHH)  or
             (iAna.sH1   <>dAna[i].sH1)  or
             (iAna.sH    <>dAna[i].sH )  or
             (iAna.sL    <>dAna[i].sL )  or
             (iAna.sL1   <>dAna[i].sL1)  or
             (iAna.sLL   <>dAna[i].sLL)  or
             (iAna.sLL1  <>dAna[i].sLL1) or
			 (iAna.sLLm  <>dAna[i].sLLm) or 
			 (iAna.sOk   <>dAna[i].sOk)  or 
             (iAna.sError<>dAna[i].sError); 
(* Срабатывание по таймеру *) 
  if iAna.mTimer1>0.0 then
    iAna.sHH1:= dAna[i].sHH1;
    iAna.sHH := dAna[i].sHH;
    iAna.sH1 := dAna[i].sH1;
    iAna.sH  := dAna[i].sH;
    iAna.sL  := dAna[i].sL;
    iAna.sL1 := dAna[i].sL1;
    iAna.sLL := dAna[i].sLL;
    iAna.sLL1:= dAna[i].sLL1;
  end_if;
(* ------------------------------------------------------------- *)
(* ------------------------------------------------------------- *)
(* Обработка данных Hart *) 
(* Диагностика Hart *) 
  iAna.sHartEnable:= dAnaHart[i].xHart.hartSelected>0 or dAnaHart[i].xHartR.hartSelected>0; 	(* Есть каналы Hart *)
 
 
 (*if iAna.sOkHartM then 
   iAna.mTimer2:= _fTimer(
      Start := not iAna.eHartM & dAnaHart[i].xHart.hartSelected>0 & dAnaHart[i].xHart.responseError,
      Stop  := not dAnaHart[i].xHart.responseError,
      tTimer:= iAna.nTimer2,
      mTimer:= iAna.mTimer2);
   if iAna.sOkHartR then 
   iAna.mTimer2:= _fTimer(
      Start := dAnaHart[i].xHartR.hartSelected>0  & dAnaHart[i].xHartR.responseError, 
      Stop  := not dAnaHart[i].xHartR.responseError,
      tTimer:= iAna.nTimer2,
      mTimer:= iAna.mTimer2); 
  end_if; *)
(* ------------------------------------------------------------- *)
  (* Неисправен канал Hart Основной *)
  iAna.eHartM  := dAna[i].eCurrM or 
  				 ((iAna.eHartM or iAna.mTimer2=-1.0) & dAnaHart[i].xHart.responseError   & not (dAnaHart[i].xHart.hartSelected=0));			
  (* Неисправен канал Hart Резервный *)
  iAna.eHartR  := dAna[i].eCurrR or 
                 ((iAna.eHartR or iAna.mTimer2=-1.0) & dAnaHart[i].xHartR.responseError  & not (dAnaHart[i].xHartR.hartSelected=0));   			

  iAna.sOkHartM:= dAnaHart[i].xHart.hartSelected>0   & not dAnaHart[i].xHart.responseError  & not dAna[i].eHartM;		(* Канал Hart Основной.  В работе *)
  iAna.sOkHartR:= dAnaHart[i].xHartR.hartSelected>0  & not dAnaHart[i].xHartR.responseError & not dAna[i].eHartR;		(* Канал Hart Резервный. В работе *)

  iAna.sHartError := iAna.sHartEnable & ((iAna.nCurrR & (iAna.eHartM or iAna.eHartR)) or 
                                         (not iAna.nCurrR & iAna.eHartM));	                    (* Неисправность канала Hart *)
(* ------------------------------------------------------------- *)
(* Т02 Фильтрация диагностики Hart *) 
 iAna.mTimer2:= _fTimer(
      Start :=  ((dAnaHart[i].xHart.hartSelected>0 & dAnaHart[i].xHart.responseError) or 
	  			 (dAnaHart[i].xHartR.hartSelected>0 & dAnaHart[i].xHartR.responseError)),
      Stop  := ((iAna.eHartM or not dAnaHart[i].xHart.responseError) or 
	  			(iAna.eHartR or not dAnaHart[i].xHartR.responseError)),
      tTimer:= iAna.nTimer2,
      mTimer:= iAna.mTimer2);

(* ------------------------------------------------------------- *)
  if iAna.sHartEnable then 
	(* Вывод данных HART *)
    if iAna.sOkHartM and not iAna.sOkHartR then
	  dAnaHart[i].xHartPV:= dAnaHart[i].xHart.HART[1]; 			dAnaHart[i].xHartSV:= dAnaHart[i].xHart.HART[2];
	  dAnaHart[i].xHartTV:= dAnaHart[i].xHart.HART[3]; 			dAnaHart[i].xHartQV:= dAnaHart[i].xHart.HART[4];
	end_if;
    if iAna.sOkHartR and not iAna.sOkHartM then
	  iAna.yHartValue:= dAnaHart[i].xHartR.HART[iAna.nHartSel+1]; 
	  dAnaHart[i].xHartPVR:= dAnaHart[i].xHartR.HART[1]; 		dAnaHart[i].xHartSVR:= dAnaHart[i].xHartR.HART[2];
	  dAnaHart[i].xHartTVR:= dAnaHart[i].xHartR.HART[3]; 		dAnaHart[i].xHartQVR:= dAnaHart[i].xHartR.HART[4];
	end_if;
    (* Комады переключения вывода yHartValue *)
	if iAna.cHartSelFV then iAna.nHartSel:= 0; end_if;
	if iAna.cHartSelSV then iAna.nHartSel:= 1; end_if;
	if iAna.cHartSelTV then iAna.nHartSel:= 2; end_if;
	if iAna.cHartSelQV then iAna.nHartSel:= 3; end_if;
	(* Вывод переменой *)
	if iAna.nHartSel<0 or iAna.nHartSel>3 then iAna.nHartSel:= 0; end_if;
    if iAna.sOkHartM and not iAna.sOkHartR then	iAna.yHartValue:= dAnaHart[i].xHart.HART[iAna.nHartSel+1];  end_if;
    if iAna.sOkHartR and not iAna.sOkHartM then	iAna.yHartValue:= dAnaHart[i].xHartR.HART[iAna.nHartSel+1]; end_if;
	(* Вывод битов для ВУ *)
	case iAna.nHartSel of 
	  0: iAna.sHartSel1:= false; iAna.sHartSel2:= false;
	  1: iAna.sHartSel1:= false; iAna.sHartSel2:= true;
	  2: iAna.sHartSel1:= true;  iAna.sHartSel2:= false;
	  3: iAna.sHartSel1:= true;  iAna.sHartSel2:= true;
	end_case;
  end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Конец логики *)
(* Состояния панели*)
 if iAna.sHLm or iAna.sLLm THEN
 iAna.pState:= 1;
 ELSIF iAna.sHH1 or iAna.sLL1 or iAna.sHH or iAna.sLL THEN 
 iAna.pState := 2;
 ELSIF iAna.sH1 or iAna.sL1 or iAna.sH or iAna.sL THEN 
 iAna.pState := 3;
 ELSIF iAna.sOk THEN 
 iAna.pState := 5;
 else iAna.pState := 0;
 END_IF;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сохраняемые переменные (сохранение данных) *)
  rAna[i].Value         :=   iAna.Value;                         (* Значение *)      
  rAna[i].sMask         :=   iAna.sMask;                         (* Маскирование установлено *)
  rAna[i].sImit         :=   iAna.sImit;                         (* Имитация установлена *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Упаковка сообщений для команд *)
  iAna.Command.0        := iAna.cImitOn;                         (* Команда оператора. Режим имитации Включить *)
  iAna.Command.1        := iAna.cImitOff;                        (* Команда оператора. Режим имитации Отключить *)
  iAna.Command.2        := iAna.cMaskOn;                         (* Команда оператора. Режим маскирования Включить *)
  iAna.Command.3        := iAna.cMaskOff;                        (* Команда оператора. Режим маскирования Отключить *)
  iAna.Command.4        := iAna.cHartSelFV;                      (* Команда оператора. Выбор канала Hart FV *)
  iAna.Command.5        := iAna.cHartSelSV;                      (* Команда оператора. Выбор канала Hart SV *)
  iAna.Command.6        := iAna.cHartSelTV;                      (* Команда оператора. Выбор канала Hart TV *)
  iAna.Command.7        := iAna.cHartSelQV;                      (* Команда оператора. Выбор канала Hart QV *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Cообщения для команд *)
  iAna.MsAck_State:= ANY_TO_WORD(cInit);
  if iAna.MsAck_State >iAna.oMsAck_State then iAna.MsEvt_Command:= 0;                  end_if;
  if iAna.Command    <>0                 then iAna.MsEvt_Command:= iAna.Command;       end_if;
  iAna.oMsAck_State:= iAna.MsAck_State;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сброс команд *)
  iAna.Command:= 0;
  iAna.cImitOn          := false;                                (* Команда оператора. Режим имитации Включить *)
  iAna.cImitOff         := false;                                (* Команда оператора. Режим имитации Отключить *)
  iAna.cMaskOn          := false;                                (* Команда оператора. Режим маскирования Включить *)
  iAna.cMaskOff         := false;                                (* Команда оператора. Режим маскирования Отключить *)
  iAna.cHartSelFV       := false;                                (* Команда оператора. Выбор канала Hart FV *)
  iAna.cHartSelSV       := false;                                (* Команда оператора. Выбор канала Hart SV *)
  iAna.cHartSelTV       := false;                                (* Команда оператора. Выбор канала Hart TV *)
  iAna.cHartSelQV       := false;                                (* Команда оператора. Выбор канала Hart QV *)(* ------------------------------------------------------------------------------------------------------------------ *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Передача из Рабочего объекта *)
  dAna[i]:= iAna;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Отключение резевных объектов *)
end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Отключение резервных объектов: Сброс состояния объекта *)
if dAna[i].nLogicNot & not dAna[i].oLogicNot then
  dAna[i].sHLm          := false;                                (* Выше шкалы датчика *)
  dAna[i].sHH1          := false;                                (* Верхний Аварийный (HH1) *)
  dAna[i].sHH           := false;                                (* Верхний Аварийный (HH) *)
  dAna[i].sH            := false;                                (* Верхний Предупредительный (H) *)
  dAna[i].sOk           := false;                                (* В норме *)       
  dAna[i].sL            := false;                                (* Нижний Предупредительный (L) *)
  dAna[i].sLL           := false;                                (* Нижний Аварийный (LL) *)
  dAna[i].sLL1          := false;                                (* Нижний Аварийный (LL1) *)
  dAna[i].sLLm          := false;                                (* Ниже шкалы датчика *)
  dAna[i].sError        := false;                                (* Неисправность канала *)
  dAna[i].sMask         := false;                                (* Режим Ремонт *)  
  dAna[i].sImit         := false;                                (* Имитация *)      
  dAna[i].sEnableHH1    := false;                                (* Включена в работу Уставка Верхний Аварийный (HH1) *)
  dAna[i].sEnableHH     := false;                                (* Включена в работу Уставка Верхний Аварийный (HH) *)
  dAna[i].sEnableH      := false;                                (* Включена в работу Уставка Верхний Предупредительный (H) *)
  dAna[i].sEnableL      := false;                                (* Включена в работу Уставка Нижний Предупредительный (L) *)
  dAna[i].sEnableLL     := false;                                (* Включена в работу Уставка Нижний Аварийный (LL) *)
  dAna[i].sEnableLL1    := false;                                (* Включена в работу Уставка Нижний Аварийный (LL1) *)
  dAna[i].eCurrM        := false;                                (* Неисправен канал Основной *)
  dAna[i].eCurrR        := false;                                (* Неисправен канал Резервный *)
  dAna[i].sOkCurrM      := false;                                (* Активен канал Основной *)
  dAna[i].sOkCurrR      := false;                                (* Активен канал Резервный *)
  dAna[i].sH1           := false;                                (* Верхний Предупредительный (H1) *)
  dAna[i].sL1           := false;                                (* Нижний Предупредительный (L1) *)
  dAna[i].sEnableH1     := false;                                (* Включена в работу Уставка Верхний Предупредительный (H1) *)
  dAna[i].sEnableL1     := false;                                (* Включена в работу Уставка Нижний Предупредительный (L1) *)
  dAna[i].sHartError    := false;                                (* Неисправность канала Hart *)
  dAna[i].sHartEnable   := false;                                (* Есть каналы Hart *)
  dAna[i].sHartSel1     := false;                                (* Выбор канала Hart *)
  dAna[i].sHartSel2     := false;                                (* Выбор канала Hart *)
  dAna[i].sErrSensor    := false;                                (* Неисправность датчика (внешняя) *)
(* maskStateNone=2080374783 *)
end_if;
dAna[i].oLogicNot:= dAna[i].nLogicNot;
(* ------------------------------------------------------------------------------------------------------------------ *)
i:= i+1; end_while;
END_FUNCTION