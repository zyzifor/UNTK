FUNCTION processDioCPU_502
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Name            Data Type      Dimension            Direction  Attribute       Comment                             *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* processDioCPU  DINT                                VarOutput  Write           Результат выполнения функции *)
(* iDioCPU         typDioCPU                           Var        Read/Write      Рабочий объект *)
(* i               DINT                                Var        Read/Write      Счётчик *)
(* _bRes           BOOL                                Var        Read/Write      Результат функции BOOL *)
(* _dRes           DINT                                Var        Read/Write      Результат функции DINT *)
(* ------------------------------------------------------------------------------------------------------------------ *)
processDioCPU_502:= sDioCPU.iSize;
if sDioCPU.iSize>sDioCPU.iMax then processDioCPU_502:= -sDioCPU.iSize; return; end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Определение оснновного CPU в системе *)
_sMain:= false;
i:= 1;   while i<=sDioCPU.iSize do
  _sMain:= _sMain or dDioCPU[i].sMain; 
i:= i+1; end_while;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Проход по всем параметрам *)
i:= 1;   while i<=sDioCPU.iSize do
  (* ------------------------------------------------------------------------------------------------------------------ *)
  (* Отключение резевных объектов *)
  if not dDioCPU[i].nLogicNot then
   (* ------------------------------------------------------------------------------------------------------------------ *)
   (* Передача в Рабочий объект *)
    iDioCPU:= dDioCPU[i];
(* ------------------------------------------------------------------------------------------------------------------ *)
    (* Сохраняемые переменные (чтение при первом скане) *)
    if nPrgModify then iDioCPU.oRsrCRC32   := rDioCPU[i].oRsrCRC32; end_if;                (* CRC32 файлов ресурса в CPU (предыдущее) *)
(* ------------------------------------------------------------------------------------------------------------------ *)
    (* проверка nDio *)
    if iDioCPU.nDio>=1 & iDioCPU.nDio<=sDio.iSize then 
      iDio:= dDio[iDioCPU.nDio];
    (* ------------------------------------------------------ *)
    (* проверка типа модуля *)
      if iDio.nType=100501022 or iDio.nType=100502142 or iDio.nType=100503120 then
	    iDioCPU.MsAck_State:= ANY_TO_WORD(cInit);
	    iDio.MsAck_State:= ANY_TO_WORD(cInit);
(* ---------------------------------------------------- *)
        (* корзина и слот модуля *)
        _pwl_id:= ANY_TO_INT(iDio.nPlace/10000);
        _rack  := ANY_TO_INT(iDio.nPlace/100  -iDio.nPlace/10000*100);
        _slot  := ANY_TO_INT(iDio.nPlace      -iDio.nPlace/100  *100);
(* ---------------------------------------------------- *)
        (* значения *)
        iDioCPU.CPULoad   := ANY_TO_INT(iDioCPU.xCPUDiag.cpuLoad*100.0);  			(* Загрузка процессора (%x100.0) *)
        iDioCPU.CPUMemFree:= ANY_TO_INT(iDioCPU.xCPUDiag.memoryFree);  				(* Объём свободной памяти (МБ) *)
        iDioCPU.ClcCurr   := ANY_TO_UINT(iDioCPU.xSysInfo.Cycle.CurrentCycleTime);  	(* Текущее время выполнения программы пользователя (мсек) *)
        iDioCPU.ClcMax    := ANY_TO_UINT(iDioCPU.xSysInfo.Cycle.MaxCycleTime);  		(* Максимальное время выполнения программы пользователя (мсек) *)
        iDioCPU.ClcOvfl   := iDioCPU.xSysInfo.Cycle.CycleOverflows;  	            (* Число превышений заданного времени цикла *)
        iDioCPU.FOErrCode := iDioCPU.xSysInfo.Failover.ErrCode;  					(* Код ошибки Failover *)
        iDioCPU.FOSync    := ANY_TO_INT(iDioCPU.xSysInfo.Failover.DataSyncTime);  	(* Время синхронизации данных между CPU (мсек) *)
        iDioCPU.RsrMode   := ANY_TO_INT(iDioCPU.xSysInfo.ResInfo.Mode);  			(* Режим выполнения ресурса *)
        iDioCPU.RsrCRC32  := iDioCPU.xSysInfo.ResInfo.CRC32;  						(* CRC32 файлов ресурса в CPU *)
(* ---------------------------------------------------- *)
        (* состояния *)
        iDioCPU.sMain    := not (iDio.sNotComp or iDio.sNotModule) &                                                            (* В режиме Основной *)
		                    (iDioCPU.xSysInfo.Failover.IsEnable or (not iDioCPU.xSysInfo.Failover.IsEnable & not iDioCPU.xSysInfo.Failover.IsActive)) &
                            iDioCPU.xSysInfo.Failover.ActiveCPURack= _rack & iDioCPU.xSysInfo.Failover.ActiveCPUSlot= _slot;
        iDioCPU.sRes     := not (iDio.sNotComp or iDio.sNotModule) & iDioCPU.xSysInfo.Failover.IsEnable & 
                           (iDioCPU.xSysInfo.Failover.ActiveCPURack<>_rack or iDioCPU.xSysInfo.Failover.ActiveCPUSlot<>_slot) &
                            iDioCPU.xSysInfo.Failover.ActiveCPURack<>0     &  iDioCPU.xSysInfo.Failover.ActiveCPUSlot<>0 &
                            _sMain;                                                   					                        (* В режиме Резервный *)															
        iDioCPU.eFOErr   := not (iDio.sNotComp or iDio.sNotModule) & iDioCPU.xSysInfo.Failover.IsEnable & iDioCPU.FOErrCode<>0;	(* Ошибки резервирования *)
(* ---------------------------------------------------- *)
(* исправление для случая одиночного контроллера *)
		iDioCPU.sMain := iDioCPU.sMain & __SYSVA_FO_ISENABLE;
		iDioCPU.sRes := iDioCPU.sRes & __SYSVA_FO_ISENABLE;
		iDioCPU.eFOErr := iDioCPU.eFOErr & __SYSVA_FO_ISENABLE;
(* ---------------------------------------------------- *)
       (*if iDioCPU.ClcMax>ANY_TO_UINT(iDioCPU.xSysInfo.Cycle.CycleTime) then 
         if iDioCPU.ClcMax/100<10 then 
	       iDioCPU.ClcMax:= ANY_TO_UINT(iDioCPU.xSysInfo.Cycle.CycleTime) - ANY_TO_UINT(iDioCPU.ClcMax/100*2);
	     elsif iDioCPU.ClcMax/100>=10 then 
	       iDioCPU.ClcMax:= ANY_TO_UINT(iDioCPU.xSysInfo.Cycle.CycleTime) - ANY_TO_UINT(iDioCPU.ClcMax/100);				   
	     end_if;				   
       end_if;
       if ANY_TO_UINT(iDioCPU.xSysInfo.Cycle.CurrentCycleTime)>=iDioCPU.ClcMax then
         iDioCPU.ClcCurr:= iDioCPU.ClcMax - ANY_TO_UINT(iDioCPU.xSysInfo.Cycle.CurrentCycleTime/10);
       end_if;
       if iDioCPU.xSysInfo.Cycle.CurrentCycleTime>iDioCPU.xSysInfo.Cycle.CycleTime+10 then
         iDioCPU.ClcOvfl := iDioCPU.oClcOvfl;
       end_if;*)
        if not (iDio.sNotComp or iDio.sNotModule) & iDioCPU.ClcOvfl<>iDioCPU.oClcOvfl then iDioCPU.mActOScan:= iDioCPU.mActOScan+1;
        else                                                                               iDioCPU.mActOScan:= 0;
        end_if;   
        iDioCPU.eActOScan:= (iDioCPU.mActOScan>=5);									      (* Превышено время скана *)
        iDioCPU.eActOLoad:= not (iDio.sNotComp or iDio.sNotModule) & iDioCPU.CPULoad>9000;  (* Загрузка ЦП больше 90% *)										
        (* Изменён CRC32 ПО ПЛК *)
        if not (iDio.sNotComp or iDio.sNotModule) & iDioCPU.RsrCRC32<>iDioCPU.oRsrCRC32 then iDioCPU.sCRC32Ch:= iDioCPU.sMain; end_if;					
        if iDio.MsAck_State >iDio.oMsAck_State                                          then iDioCPU.sCRC32Ch:= false;         end_if;																				
        (* Программа ПЛК. Полная перегагрузка и Изменение программы *)
        if iDioCPU.nDtTm>0 & iDioCPU.nDtTm<=sDtTm.iSize & not (iDio.sNotComp or iDio.sNotModule) then
          (* Программа ПЛК. Полная перегагрузка *)
	      if not iDioCPU.sPrgModify &     dDtTm[iDioCPU.nDtTm].sPrgModify then iDioCPU.sPrgModify:= iDioCPU.sMain;   end_if;
	      if iDio.MsAck_State >iDio.oMsAck_State                          then iDioCPU.sPrgModify:= false;           end_if;
	      iDioCPU.DatePrgModify:= dDtTm[iDioCPU.nDtTm].DatePrgModify; 
	      iDioCPU.TimePrgModify:= dDtTm[iDioCPU.nDtTm].TimePrgModify; 
          (* Программа ПЛК. Изменение программы *)
	      if not iDioCPU.sPrgChange &     dDtTm[iDioCPU.nDtTm].sPrgChange then iDioCPU.sPrgChange:= iDioCPU.sMain;   end_if;
	      if iDio.MsAck_State >iDio.oMsAck_State                          then iDioCPU.sPrgChange:= false;           end_if;
	      iDioCPU.DatePrgChange:= dDtTm[iDioCPU.nDtTm].DatePrgChange; 
	      iDioCPU.TimePrgChange:= dDtTm[iDioCPU.nDtTm].TimePrgChange;
	      (* Программа ПЛК. Изменение программы. Счётчик *)
	      iDioCPU.CntPrgChange := dDtTm[iDioCPU.nDtTm].CntPrgChange;
        end_if;
(* ---------------------------------------------------- *)
        (* индикация *)
        iDioCPU.ledPrim  := iDioCPU.sMain or iDioCPU.sRes;							(* Индикатор Prim - горит *)
        iDioCPU.blkPrim  := iDioCPU.sRes;											(* Индикатор Prim - мигает *)
        iDioCPU.ledAct   := not (iDio.sNotComp or iDio.sNotModule);					(* Индикатор Act - горит *)
        iDioCPU.blkAct   := iDioCPU.eActOScan or iDioCPU.eActOLoad;					(* Индикатор Act - мигает *)
        iDioCPU.ledFOErr := iDioCPU.eFOErr;											(* Индикатор FOErr - горит *)
(* ---------------------------------------------------- *)
        (* предыдущие данные *)
        iDioCPU.oClcOvfl := iDioCPU.ClcOvfl;  										(* Число превышений заданного времени цикла *)
        iDioCPU.oRsrCRC32:= iDioCPU.RsrCRC32;  										(* CRC32 файлов ресурса в CPU *)
(* ---------------------------------------------------- *)
        j:= 1;   while j<=7 do
 	       (* Установлен *)
	       _PEthPresent:= not iDio.sNotModule & iDioCPU.xCPUDiag.ethernetPorts[j].present;
	       case j of 
	         6:  iDioCPU.nP01RSPresent     := iDioCPU.nP01RSPresent      & _PEthPresent;    (* Порт 1RS. Установлен *)
	         7:  iDioCPU.nP02RSPresent     := iDioCPU.nP02RSPresent      & _PEthPresent;    (* Порт 2RS. Установлен *)
	         1:  iDioCPU.nP03FOPresent     := iDioCPU.nP03FOPresent      & _PEthPresent;    (* Порт Fiber Optic/SFP. Установлен *)
	         2:  iDioCPU.nP04Present       := iDioCPU.nP04Present        & _PEthPresent;    (* Порт 1 Ethernet. Установлен *)
	         3:  iDioCPU.nP05Present       := iDioCPU.nP05Present        & _PEthPresent;    (* Порт 2 Ethernet. Установлен *)
	         4:  iDioCPU.nP06Present       := iDioCPU.nP06Present        & _PEthPresent;    (* Порт 3 Ethernet. Установлен *)
	         5:  iDioCPU.nP07Present       := iDioCPU.nP07Present        & _PEthPresent;    (* Порт 4 Ethernet. Установлен *)
	       end_case;
           (* Нет связи *)
	       _PEthUplink := iDioCPU.xCPUDiag.ethernetPorts[j].uplink;
	       case j of 
	         6:  iDioCPU.eP01RSNotLink     := iDioCPU.nP01RSPresent      & not _PEthUplink;  (* Порт 1 RS. Нет связи *)
	         7:  iDioCPU.eP02RSNotLink     := iDioCPU.nP02RSPresent      & not _PEthUplink;  (* Порт 2 RS. Нет связи *)
	         1:  iDioCPU.eP03FONotLink     := iDioCPU.nP03FOPresent      & not _PEthUplink;  (* Порт Fiber Optic/SFP. Нет связи *)
	         2:  iDioCPU.eP04NotLink       := iDioCPU.nP04Present        & not _PEthUplink;  (* Порт 1 Ethernet. Нет связи *)
	         3:  iDioCPU.eP05NotLink       := iDioCPU.nP05Present        & not _PEthUplink;  (* Порт 2 Ethernet. Нет связи *)
	         4:  iDioCPU.eP06NotLink       := iDioCPU.nP06Present        & not _PEthUplink;  (* Порт 3 Ethernet. Нет связи *)
	         5:  iDioCPU.eP07NotLink       := iDioCPU.nP07Present        & not _PEthUplink;  (* Порт 4 Ethernet. Нет связи *)
	       end_case;
        j:=j+1; end_while;
(* ------------------------------------------------------ *)
        (* Диагностика модуля МК-502 *)
        (* Нет связи *)
        iDio.sFONotLink:= iDioCPU.eP03FONotLink;      (* Порт Fiber Optic/SFP. Нет связи *)
        iDio.sP1NotLink:= iDioCPU.eP04NotLink;        (* Порт 1 Ethernet. Нет связи *)
        iDio.sP2NotLink:= iDioCPU.eP05NotLink;        (* Порт 2 Ethernet. Нет связи *)
        iDio.sP3NotLink:= iDioCPU.eP06NotLink;        (* Порт 2 Ethernet. Нет связи *)
        iDio.sP4NotLink:= iDioCPU.eP07NotLink;        (* Порт 3 Ethernet. Нет связи *)
        (* Есть связь *)
        iDio.sFOLink:= not iDio.sFONotLink & iDioCPU.nP03FOPresent;        (* Порт Fiber Optic/SFP. Есть связь *)
        iDio.sP1Link:= not iDio.sP1NotLink & iDioCPU.nP04Present;          (* Порт 1 Ethernet. Есть связь *)
        iDio.sP2Link:= not iDio.sP2NotLink & iDioCPU.nP05Present;          (* Порт 2 Ethernet. Есть связь *)
        iDio.sP3Link:= not iDio.sP3NotLink & iDioCPU.nP06Present;          (* Порт 3 Ethernet. Есть связь *)
        iDio.sP4Link:= not iDio.sP4NotLink & iDioCPU.nP07Present;          (* Порт 4 Ethernet. Есть связь *)
(* ---------------------------------------------------- *)
        (* передача данных в Dio *)
        dDio[iDioCPU.nDio]:= iDio;
      end_if;
    end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
    (* Cообщения для команд *)
    iDioCPU.oMsAck_State:= iDioCPU.MsAck_State;
(* ------------------------------------------------------------------------------------------------------------------ *)
    (* Сохраняемые переменные (сохранение данных) *)
    rDioCPU[i].oRsrCRC32  :=   iDioCPU.oRsrCRC32;                  (* CRC32 файлов ресурса в CPU (предыдущее) *)
(* ------------------------------------------------------------------------------------------------------------------ *)
    (* Передача из Рабочего объекта *)
    dDioCPU[i]:= iDioCPU;
(* ------------------------------------------------------------------------------------------------------------------ *)
    (* Отключение резевных объектов *)
  end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
  (* Отключение резервных объектов: Сброс состояния объекта *)
  if dDioCPU[i].nLogicNot & not dDioCPU[i].oLogicNot then
    dDioCPU[i].sMain      := false;                                (* В режиме Основной *)
    dDioCPU[i].sRes       := false;                                (* В режиме Резервный *)
    dDioCPU[i].sCRC32Ch   := false;                                (* Изменён CRC32 *) 
    dDioCPU[i].sPrgChange := false;                                (* Программа ПЛК. Изменение программы *)
    dDioCPU[i].sPrgModify := false;                                (* Программа ПЛК. Полная перегагрузка *)
  (* maskStateNone=227 *)
  end_if;
  dDioCPU[i].oLogicNot:= dDioCPU[i].nLogicNot;
(* ------------------------------------------------------------------------------------------------------------------ *)
i:= i+1; end_while;

END_FUNCTION