FUNCTION processDsc
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Name            Data Type      Dimension            Direction  Attribute       Comment                             *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* processDsc     DINT                                VarOutput  Write           Результат выполнения функции *)
(* iDsc            typDsc                              Var        Read/Write      Рабочий объект *)
(* i               DINT                                Var        Read/Write      Счётчик *)
(* _bRes           BOOL                                Var        Read/Write      Результат функции BOOL *)
(* _dRes           DINT                                Var        Read/Write      Результат функции DINT *)
(* ------------------------------------------------------------------------------------------------------------------ *)
processDsc:= sDsc.iSize;
if sDsc.iSize>sDsc.iMax then processDsc:= -sDsc.iSize; return; end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Проход по всем параметрам *)
i:= 1;   while i<=sDsc.iSize do
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Отключение резевных объектов *)
if not dDsc[i].nLogicNot then
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Передача в Рабочий объект *)
  iDsc:= dDsc[i];
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сохраняемые переменные (чтение при первом скане) *)
  if iPrgModify then
    iDsc.sImit          := rDsc[i].sImit;                        (* Имитация *)      
    iDsc.sMask          := rDsc[i].sMask;                        (* Маскирование *)  
    iDsc.sInput         := rDsc[i].sInput;                       (* Вход для имитации *)
  end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Начало логики *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Имитация *)    
  iDsc.sImit:= (iDsc.sImit or iDsc.cImitOn) & not iDsc.cImitOff;
(* Маскирование *)    
  iDsc.sMask:= (iDsc.sMask or iDsc.cMaskOn) & not iDsc.cMaskOff;
(* Обработка Контр. целостности цепи *) 
  iDsc.sControl:= not iDsc.xControl & iDsc.nControl & not iDsc.xErrCtrl & not iDsc.sMask;
(* Обработка состояний *) 
  if not iDsc.sImit then
   case iDsc.nModeInput of
     0:        (* Нет режима *)
        iDsc.sOn   := ((not iDsc.nInvert & iDsc.xInput) or (iDsc.nInvert & not iDsc.xInput)) & not iDsc.sMask & 
		              not iDsc.xError & not iDsc.sControl;
        iDsc.sError:= iDsc.xError & not iDsc.sMask;
     1:       (* основной канал *)
        iDsc.sOn   := ((not iDsc.nInvert & iDsc.xInput) or (iDsc.nInvert & not iDsc.xInput)) & not iDsc.sMask & 
		              not iDsc.xError & not iDsc.sControl;
        iDsc.sError:= iDsc.xError & not iDsc.sMask;
        iDsc.sErrM := iDsc.sError;
     2:      (* резервный канал *)
        iDsc.sOn   := ((not iDsc.nInvert & iDsc.xInputR) or (iDsc.nInvert & not iDsc.xInputR)) & not iDsc.sMask & 
		              not iDsc.xErrorR & not iDsc.sControl;
        iDsc.sError:= iDsc.xErrorR & not iDsc.sMask;
        iDsc.sErrR := iDsc.sError;
     3:      (* основной и резервный каналы по логике "И"  *)
        iDsc.sOn   := ((not iDsc.nInvert & ((    iDsc.xInput and not iDsc.xError) and (    iDsc.xInputR and not iDsc.xErrorR ))) or 
                           (iDsc.nInvert & ((not iDsc.xInput and not iDsc.xError) and (not iDsc.xInputR and not iDsc.xError)))) & not iDsc.sMask;
        iDsc.sError:= (iDsc.xError or iDsc.xErrorR) & not iDsc.sMask;
        iDsc.sErrM := iDsc.xError & not iDsc.sMask;
        iDsc.sErrR := iDsc.xErrorR & not iDsc.sMask;
     4:      (* основной и резервный каналы по логике "ИЛИ" *)
        iDsc.sOn   := ((not iDsc.nInvert & ((    iDsc.xInput and not iDsc.xError) or (     iDsc.xInputR and not iDsc.xErrorR ))) or 
                           (iDsc.nInvert & ((not iDsc.xInput and not iDsc.xError) or  (not iDsc.xInputR and not iDsc.xError)))) & not iDsc.sMask;
        iDsc.sError:= (iDsc.xError or iDsc.xErrorR) & not iDsc.sMask;
        iDsc.sErrM := iDsc.xError & not iDsc.sMask;
        iDsc.sErrR := iDsc.xErrorR & not iDsc.sMask;
    end_case; 
    iDsc.sInput  := iDsc.sOn; 
  else
	iDsc.sControl:= false;
    iDsc.sInput  := (iDsc.sInput or iDsc.cInputOn ) & not iDsc.cInputOff;
    iDsc.sOn     := iDsc.sInput & not iDsc.sMask;
    iDsc.sError  := false;
  end_if; 
  iDsc.sOff:= not iDsc.sOff;  
(* Фильтрация дребезга срабатывания параметра по времени*)
  iDsc.mTimer1:=_fTimer(iDsc.sOn and not dDsc[i].sOn, not iDsc.sOn and not dDsc[i].sOn, 
                       _tTimer(iDsc.tTimer1), 
					   iDsc.mTimer1);
(* Срабатывание по таймеру  *)
  if iDsc.mTimer1>0.0 & not iDsc.sImit then  iDsc.sOn:= false; end_if;
  iDsc.sOff:= not iDsc.sOn & not iDsc.sError;
(* Cостояние изменилось  *)
  iDsc.fCh:= (iDsc.sOn<>dDsc[i].sOn) or (iDsc.sOff<>dDsc[i].sOff) or 
             (iDsc.sError<>dDsc[i].sError) or (iDsc.sControl<>dDsc[i].sControl); 
(* Дополнительное состояние *)
  iDsc.nXX:= (iDsc.nClass=dMsGrS32[sMsGrS32.MS].AH);
  iDsc.nTX:= (iDsc.nClass=dMsGrS32[sMsGrS32.MS].TX);
(*-------------------------------------------------------*)
(* Сигнализация по классам *) 
  if iDsc.nClass=0 then iDsc.nClass:= dMsGrS32[sMsGrS32.MS].AH; end_if;
  iDsc.sOn1:= (iDsc.nClass = dMsGrS32[sMsGrS32.MS].AH) & iDsc.sOn;         (* Alarm  *)
  iDsc.sOn2:= (iDsc.nClass = dMsGrS32[sMsGrS32.MS].WH) & iDsc.sOn;         (* Warning *)
  iDsc.sOn3:= (iDsc.nClass = dMsGrS32[sMsGrS32.MS].TX) & iDsc.sOn;         (* Norm *)
  iDsc.sOn4:= (iDsc.nClass = dMsGrS32[sMsGrS32.MS].ER) & iDsc.sOn;         (* PLC Process Control Error*)
  iDsc.sOn5:= (iDsc.nClass = dMsGrS32[sMsGrS32.MS].PM) & iDsc.sOn;         (* Process message *)                         
  iDsc.sOn6:= (iDsc.nClass = dMsGrS32[sMsGrS32.MS].FL) & iDsc.sOn;         (* PLC Process Control Fault *)                         
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Конец логики *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сохраняемые переменные (сохранение данных) *)
  rDsc[i].sImit         :=   iDsc.sImit;                         (* Имитация *)      
  rDsc[i].sMask         :=   iDsc.sMask;                         (* Маскирование *)  
  rDsc[i].sInput        :=   iDsc.sInput;                        (* Вход для имитации *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Упаковка сообщений для команд *)
  iDsc.Command.0        := iDsc.cImitOn;                         (* Команда оператора. Режим имитации Включить *)
  iDsc.Command.1        := iDsc.cImitOff;                        (* Команда оператора. Режим имитации Отключить *)
  iDsc.Command.2        := iDsc.cMaskOn;                         (* Команда оператора. Режим Ремонт Включить *)
  iDsc.Command.3        := iDsc.cMaskOff;                        (* Команда оператора. Режим Ремонт Отключить *)
  iDsc.Command.4        := iDsc.cInputOn;                        (* Команда оператора. Имитировать Включен *)
  iDsc.Command.5        := iDsc.cInputOff;                       (* Команда оператора. Имитировать Отключен *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Cообщения для команд *)
  iDsc.MsAck_State:= ANY_TO_WORD(cInit);
  if iDsc.MsAck_State >iDsc.oMsAck_State then iDsc.MsEvt_Command:= 0;                  end_if;
  if iDsc.Command    <>0                 then iDsc.MsEvt_Command:= iDsc.Command;       end_if;
  iDsc.oMsAck_State:= iDsc.MsAck_State;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сброс команд *)
  iDsc.Command:= 0;
  iDsc.cImitOn          := false;                                (* Команда оператора. Режим имитации Включить *)
  iDsc.cImitOff         := false;                                (* Команда оператора. Режим имитации Отключить *)
  iDsc.cMaskOn          := false;                                (* Команда оператора. Режим Ремонт Включить *)
  iDsc.cMaskOff         := false;                                (* Команда оператора. Режим Ремонт Отключить *)
  iDsc.cInputOn         := false;                                (* Команда оператора. Имитировать Включен *)
  iDsc.cInputOff        := false;                                (* Команда оператора. Имитировать Отключен *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Передача из Рабочего объекта *)
  dDsc[i]:= iDsc;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Отключение резевных объектов *)
end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Отключение резервных объектов: Сброс состояния объекта *)
if dDsc[i].nLogicNot & not dDsc[i].oLogicNot then
  dDsc[i].sOff          := false;                                (* Норма *)         
  dDsc[i].sOn           := false;                                (* Срабатывание *)  
  dDsc[i].sOn1          := false;                                (* Срабатывание *)  
  dDsc[i].sOn2          := false;                                (* Срабатывание *)  
  dDsc[i].sOn3          := false;                                (* Срабатывание *)  
  dDsc[i].sOn4          := false;                                (* Срабатывание *)  
  dDsc[i].sOn5          := false;                                (* Срабатывание *)  
  dDsc[i].sOn6          := false;                                (* Срабатывание *)  
  dDsc[i].sError        := false;                                (* Неисправность канала *)
  dDsc[i].sImit         := false;                                (* Имитация *)      
  dDsc[i].sMask         := false;                                (* Режим Ремонт *)  
  dDsc[i].sErrM         := false;                                (* Неисправен канал Основной *)
  dDsc[i].sErrR         := false;                                (* Неисправен канал Резервный *)
  dDsc[i].sInput        := false;                                (* Вход для имитации *)
  dDsc[i].sControl      := false;                                (* Неисправность датчика *)
(* maskStateNone=81919 *)
end_if;
dDsc[i].oLogicNot:= dDsc[i].nLogicNot;
(* ------------------------------------------------------------------------------------------------------------------ *)
i:= i+1; end_while;

END_FUNCTION