FUNCTION processDmb
				   
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Name            Data Type      Dimension            Direction  Attribute       Comment                             *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* processDmb     DINT                                VarOutput  Write           Результат выполнения функции *)
(* iDmb            typDmb                              Var        Read/Write      Рабочий объект *)
(* i               DINT                                Var        Read/Write      Счётчик *)
(* _bRes           BOOL                                Var        Read/Write      Результат функции BOOL *)
(* _dRes           DINT                                Var        Read/Write      Результат функции DINT *)
(* ------------------------------------------------------------------------------------------------------------------ *)
processDmb:= sDmb.iSize;
if sDmb.iSize>sDmb.iMax then processDmb:= -sDmb.iSize; return; end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Проход по всем параметрам *)
i:= 1;   while i<=sDmb.iSize do
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Отключение резевных объектов *)
if not dDmb[i].nLogicNot then
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Передача в Рабочий объект *)
  iDmb:= dDmb[i];
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сохраняемые переменные (чтение при первом скане) *)
  if nPrgModify then
    iDmb.sTest_M0       := rDmb[i].sTest_M0;                     (* Режим: Тестирование Модуль [0] *)
    iDmb.sTest_M1       := rDmb[i].sTest_M1;                     (* Режим: Тестирование Модуль [1] *)
    iDmb.sTest_M2       := rDmb[i].sTest_M2;                     (* Режим: Тестирование Модуль [2] *)
    iDmb.sTest_M3       := rDmb[i].sTest_M3;                     (* Режим: Тестирование Модуль [3] *)
    iDmb.sTest_M4       := rDmb[i].sTest_M4;                     (* Режим: Тестирование Модуль [4] *)
    iDmb.sTest_M5       := rDmb[i].sTest_M5;                     (* Режим: Тестирование Модуль [5] *)
    iDmb.sTest_M6       := rDmb[i].sTest_M6;                     (* Режим: Тестирование Модуль [6] *)
    iDmb.sTest_M7       := rDmb[i].sTest_M7;                     (* Режим: Тестирование Модуль [7] *)
  end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Начало логики *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Проверка и номер объекта MK541N *)
iDmb.eNotMK541N:= iDmb.nDioMK541N<1 or iDmb.nDioMK541N>sDioMK541N.iSize;
if not iDmb.eNotMK541N then nDioMK541N:= iDmb.nDioMK541N; iDmb.eNotMK541N:= dDioMK541N[nDioMK541N].eDioError; end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Обработка команды *)
_onTestMod:= -1; _offTestMod:= -1;  
if iDmb.CommCode>0 then
(* Включение/Отключение режима тестирования 
   Кодировка: PCNN 
   C:  Команда (1 - Включить/2 - Отключить 
   NN: Номер модуля *)
  _CommCode:= ANY_TO_DINT(iDmb.CommCode);   
  case _CommCode/100 of
	1:  _onTestMod:= _CommCode-(_CommCode/100)*100;
	2: _offTestMod:= _CommCode-(_CommCode/100)*100;
  end_case;
  (* Установка/Снятие режима Тестирования *)
  iDmb.sTest_M0:= (iDmb.sTest_M0 or (_onTestMod=0)) & not (_offTestMod=0);
  iDmb.sTest_M1:= (iDmb.sTest_M1 or (_onTestMod=1)) & not (_offTestMod=1);
  iDmb.sTest_M2:= (iDmb.sTest_M2 or (_onTestMod=2)) & not (_offTestMod=2);
  iDmb.sTest_M3:= (iDmb.sTest_M3 or (_onTestMod=3)) & not (_offTestMod=3);
  iDmb.sTest_M4:= (iDmb.sTest_M4 or (_onTestMod=4)) & not (_offTestMod=4);
  iDmb.sTest_M5:= (iDmb.sTest_M5 or (_onTestMod=5)) & not (_offTestMod=5);
  iDmb.sTest_M6:= (iDmb.sTest_M6 or (_onTestMod=6)) & not (_offTestMod=6);
  iDmb.sTest_M7:= (iDmb.sTest_M7 or (_onTestMod=7)) & not (_offTestMod=7);
end_if;
iDmb.CommCode:= 0;
(* ------------------------------------------------------ *)
(* WORD в обратном порядке *)
dDmbData[i].nSwapWORD.0:= iDmb.nSwapWORD_M0;   (* Виртуальный модуль 0: WORD в обратном порядке *)
dDmbData[i].nSwapWORD.1:= iDmb.nSwapWORD_M1;   (* Виртуальный модуль 1: WORD в обратном порядке *)
dDmbData[i].nSwapWORD.2:= iDmb.nSwapWORD_M2;   (* Виртуальный модуль 2: WORD в обратном порядке *)
dDmbData[i].nSwapWORD.3:= iDmb.nSwapWORD_M3;   (* Виртуальный модуль 3: WORD в обратном порядке *)
dDmbData[i].nSwapWORD.4:= iDmb.nSwapWORD_M4;   (* Виртуальный модуль 4: WORD в обратном порядке *)
dDmbData[i].nSwapWORD.5:= iDmb.nSwapWORD_M5;   (* Виртуальный модуль 5: WORD в обратном порядке *)
dDmbData[i].nSwapWORD.6:= iDmb.nSwapWORD_M6;   (* Виртуальный модуль 6: WORD в обратном порядке *)
dDmbData[i].nSwapWORD.7:= iDmb.nSwapWORD_M7;   (* Виртуальный модуль 7: WORD в обратном порядке *)
(* ------------------------------------------------------ *)
(* Чтение статусов и запросов *)
if not iDmb.eNotMK541N then 
  case iDmb.nPort of 
    1: iPnStatus:= dDioMK541NData[nDioMK541N].xP1Status; iPnRequest:= dDioMK541NData[nDioMK541N].yP1Request;
    2: iPnStatus:= dDioMK541NData[nDioMK541N].xP2Status; iPnRequest:= dDioMK541NData[nDioMK541N].yP2Request;
  end_case;
end_if;
(* ------------------------------------------------------ *)
(* Сброс состояний *)
sOk:= true; eNotLink:= true; eErrLink:= false;
(* ------------------------------------------------------ *)
(* Расшифровка данных модуля *)
iDmb.nOffs[0]:= 0;
m:= 0; while m<=7 do
  _modType[m] := iDmb.nType[m]/1000;
  _modVar[m]  := iDmb.nType[m]/100-iDmb.nType[m]/1000*10;
  _modSize[m] := ANY_TO_INT(MOD(ANY_TO_DINT(iDmb.nType[m]), 100));
  (* расчёт смещений *)
  case ANY_TO_DINT(_modVar[m]) of
    0: _modSizeW[m]:= ANY_TO_DINT(_modSize[m]);			 (* WORD *)
    1: _modSizeW[m]:= ANY_TO_DINT(_modSize[m])*2;        (* DWORD *)
    2: _modSizeW[m]:= ANY_TO_DINT(_modSize[m])*2;        (* REAL *)
	3: _modSizeW[m]:= ANY_TO_DINT(_modSize[m])/16;       (* BOOL *)
  end_case; 
  (* тип модуля для записи *)
  _nRW[m] := _modType[m]=3 or _modType[m]=4;
  (* расчёт смещений в dData и RawData *)
  if m=0 or iDmb.nMK541Offs[m]>0 then
    _nMK541Offs[m]:= iDmb.nMK541Offs[m];
  elsif	_modSizeW[m]>0 then
	 iDmb.nOffs[m]:=  iDmb.nOffs[m-1]+_modSizeW[m-1];
    _nMK541Offs[m]:= _nMK541Offs[m-1]+_modSizeW[m-1];
  else
	 iDmb.nOffs[m]:= -1;
    _nMK541Offs[m]:= -1;
  end_if;
m:= m+1; end_while; 
(* ------------------------------------------------------ *)
(* Запросы по модулям *)
_sTestMask:= 0; _sTestPort:= 0; _sTestReq:= -1;
if not iDmb.nSlave & (iDmb.nPort=1 or iDmb.nPort=2) then
  m:= 0; while m<=7 do
	(* запросы *)
	nReq:= iDmb.nMK541Req[m];
	if nReq>=0 and nReq<=63 then
	  iPnRequest[nReq].enable           := iDmb.nFC[m]>0;  (* Установка запросов *)
	  iPnRequest[nReq].command.func_code:= ANY_TO_BYTE(iDmb.nFC[m]);
      if iPnRequest[nReq].enable then
        (* запись настроек запроса *)
	    iPnRequest[nReq].on_modify_request:= GetBitFromWord(ANY_TO_WORD(iDmb.yModify),   m);
	    iPnRequest[nReq].single_request   := GetBitFromWord(ANY_TO_WORD(iDmb.ySingle),   m);
	    iPnRequest[nReq].do_single_req    := GetBitFromWord(ANY_TO_WORD(iDmb.cDoSingle), m);
	    iPnRequest[nReq].command.slave_id         := iDmb.nId;
	    iPnRequest[nReq].command.slave_data_addr  := iDmb.nAddr[m];
	    iPnRequest[nReq].command.slave_data_length:= iDmb.nLen[m];
	    iPnRequest[nReq].command.offset           := ANY_TO_WORD(iDmb.nMK541Offs[m]-1);
	    iPnRequest[nReq].command.skip_repeats_when_bad:= iDmb.nMK541ScipRepeat[m];
	    (* статус запроса *)
	    iDmb.iStatus[m]:= iPnStatus[nReq];
	    (* статус НЕИСПРАВНОСТЬ МОДУЛЯ *)
	    if iDmb.eNotMK541N then iPnStatus[nReq]:= 98; iDmb.iStatus[m]:= 98; end_if;
        (* статус ОТКЛЮЧЕН ПОЛЬЗОВАТЕЛЕМ *)
	    if    nReq<=31 & not iDmb.eNotMK541N then 
	      if iDmb.nPort=1 & GetBitFromDWord(dDioMK541N[nDioMK541N].CommOffPort1Req00, nReq- 0) then iDmb.iStatus[m]:= 99; end_if;
	      if iDmb.nPort=2 & GetBitFromDWord(dDioMK541N[nDioMK541N].CommOffPort2Req00, nReq- 0) then iDmb.iStatus[m]:= 99; end_if;
	    elsif nReq>=32 & not iDmb.eNotMK541N then
	      if iDmb.nPort=1 & GetBitFromDWord(dDioMK541N[nDioMK541N].CommOffPort1Req32, nReq-32) then iDmb.iStatus[m]:= 99; end_if;
	      if iDmb.nPort=2 & GetBitFromDWord(dDioMK541N[nDioMK541N].CommOffPort2Req32, nReq-32) then iDmb.iStatus[m]:= 99; end_if;
	    end_if;  
	    (* состояния *)
	    eErrLink:= eErrLink or (iDmb.iStatus[m]<>  0 & iDmb.iStatus[m]<>100 & 
	                            iDmb.iStatus[m]<>  5 & iDmb.iStatus[m]<> 31 &
	                            iDmb.iStatus[m]<>254 & iDmb.iStatus[m]<>255 &
		                        iDmb.iStatus[m]<>201) & iPnRequest[nReq].enable;
	    eNotLink:= eNotLink & eErrLink;
	    (* Автоматическая подача команд на запись после включения *)
	    if iDmb.iStatus[m]<>99 & dDmb[i].iStatus[m]=99 & 
	       GetBitFromWord(ANY_TO_WORD(iDmb.nModify), m) then iDmb.cDoSingle:= ANY_TO_BYTE(SetBitToWord(true, m, ANY_TO_WORD(iDmb.cDoSingle))); end_if;
	    (* Для определения теста на запросе *)
	    _sTestMask:= SetBitToDWord(true, 16+m, 0);
	    _sTestPort:= iDmb.nPort;
	    _sTestReq := nReq;
	  end_if;	
	end_if;
	(* статус запроса шлейфом *)
    if iDmb.nFC[m]<0 and m>0 then
	  (* статус запроса *)
	  iDmb.iStatus[m]:= iDmb.iStatus[m-1]; 
	  _sTestMask:= SetBitToDWord(true, 16+m, _sTestMask);
	end_if; 
    (* статус запроса для передачи на ВУ *)
    iDmb.ErrCode[m/2]:= SetByteToWord(iDmb.iStatus[m], MOD(m, 2), iDmb.ErrCode[m/2]);
    (* состояние Тест для запроса *)
    if    _sTestReq<=31 & not iDmb.eNotMK541N then 
      if _sTestPort=1 then dDioMK541N[nDioMK541N].sTestPort1Req00:= SetBitToDWord(AND_MASK_DWORD(iDmb.State, _sTestMask)<>0, _sTestReq, dDioMK541N[nDioMK541N].sTestPort1Req00); end_if;
      if _sTestPort=2 then dDioMK541N[nDioMK541N].sTestPort2Req00:= SetBitToDWord(AND_MASK_DWORD(iDmb.State, _sTestMask)<>0, _sTestReq, dDioMK541N[nDioMK541N].sTestPort2Req00); end_if;
    elsif _sTestReq>=32 & not iDmb.eNotMK541N then
      if _sTestPort=1 then dDioMK541N[nDioMK541N].sTestPort1Req32:= SetBitToDWord(AND_MASK_DWORD(iDmb.State, _sTestMask)<>0, _sTestReq, dDioMK541N[nDioMK541N].sTestPort1Req32); end_if;
      if _sTestPort=2 then dDioMK541N[nDioMK541N].sTestPort2Req32:= SetBitToDWord(AND_MASK_DWORD(iDmb.State, _sTestMask)<>0, _sTestReq, dDioMK541N[nDioMK541N].sTestPort2Req32); end_if;
    end_if;
  m:= m+1; end_while;
end_if; 
(* ------------------------------------------------------ *)
(* Запись запросов *)
if not iDmb.eNotMK541N then 
  case iDmb.nPort of 
    1: dDioMK541NData[nDioMK541N].yP1Request:= iPnRequest;
    2: dDioMK541NData[nDioMK541N].yP2Request:= iPnRequest;
  end_case;
end_if;
(* ------------------------------------------------------ *)
(* Состояние устройства *)
iDmb.sOk	 := sOk & not eNotLink; 	      (* В норме *)
iDmb.eNotLink:= (eNotLink & iDmb.eErrLink) or iDmb.eNotMK541N;  (* Нет связи *)
(* Есть ошибки обмена *)
iDmb.eErrLink:= ((iDmb.nTimer2>0.0 & (iDmb.eErrLink or iDmb.mTimer2=-1.0)) or 
                  iDmb.nTimer2=0.0) & eErrLink;
iDmb.eErrLink:= iDmb.eErrLink or iDmb.eNotMK541N; (* Есть ошибки обмена *)
(* ------------------------------------------------------ *)
(* Настройки запросов nModify и nSingle *)
iDmb.yModify:= iDmb.nModify;
iDmb.ySingle:= OR_MASK_BYTE(iDmb.nSingle, iDmb.yModify);
(* Автоматическая подача команд на запись *)
if iDmb.eNotLink<>dDmb[i].eNotLink or iDmb.eErrLink<>dDmb[i].eErrLink then 
  iDmb.cDoSingle:= OR_MASK_BYTE(iDmb.cDoSingle, iDmb.nModify); 
end_if;
(* ------------------------------------------------------ *)
(* Таймер команды на запись *)
if iDmb.nTimer1=0.0 then iDmb.nTimer1:= 1.0; end_if;
iDmb.mTimer1:= _fTimer(
  Start := iDmb.cDoSingle>0,
  Stop  := false,
  tTimer:= iDmb.nTimer1,
  mTimer:= iDmb.mTimer1);
if iDmb.mTimer1=-1.0 then iDmb.cDoSingle:= 0; iDmb.nSingle:= 0; end_if;
(* ------------------------------------------------------ *)
(* Чтение данных объекта MK541N *)
if not iDmb.eNotMK541N then
  m:= 0; while m<=7 do
    if not _nRW[m] then
      j:= 0;   while j<=_modSizeW[m]-1 do
	    if not GetBitFromDWord(iDmb.State, 16+m) & (iDmb.iStatus[m]=0 or iDmb.iStatus[m]=100 or iDmb.iStatus[m]=31) & ((iDmb.nOffs[m]+j)<=31) then 
	      iDmb.RawData[iDmb.nOffs[m]+j]:= 
		    dDioMK541NData[nDioMK541N].dMBData.regs[_nMK541Offs[m]+j]; 
		end_if;
      j:= j+1; end_while;
    end_if;	
  m:= m+1; end_while;
end_if;
(* ------------------------------------------------------ *)
(* Распределение данных по модулям *)
m:= 0; while m<=7 do
if _modSize[m]>0 and (iDmb.nOffs[m]+_modSizeW[m]-1)<=31 then
	(* -------------------------------------------------- *)
	(* выравнивание для размерности BOOL *)
 	if _modVar[m]=3 then _modSize[m]:= ANY_TO_INT(_modSizeW[m]); end_if;
    (* -------------------------------------------------- *)
    (* проход по каналам *)
    j:= 0; while j<=ANY_TO_DINT(_modSize[m])-1 do 
      n:= iDmb.nOffs[m]+j;
      if _modVar[m]=1 or _modVar[m]=2 or (_modVar[m]=3 & _modSize[m]=2) then n:= iDmb.nOffs[m]+j*2; end_if;
	  (* ------------------------------------------------ *)
      (* AI, DI - считывание данных из RawData *)
      if    (_modType[m]=1 or _modType[m]=2) then 
	    
		case _modVar[m] of
	         0: (* WORD *)
												 
		        dDmbData[i].chData[m]:= SetBitToDWord(dDmbData[i].WData[m, j]<>_chWORD, j, dDmbData[i].chData[m]);
				dDmbData[i].WData[m, j]:= iDmb.RawData[n];
		   
		  1, 2: (* DWORD, REAL *)
				if GetBitFromWord(ANY_TO_WORD(dDmbData[i].nSwapWORD), m) then
		          _chDWORD:= SetWordToDWord(iDmb.RawData[n+1], 0, _chDWORD); 
				  _chDWORD:= SetWordToDWord(iDmb.RawData[n+0], 1, _chDWORD);
			    else		
		          _chDWORD:= SetWordToDWord(iDmb.RawData[n+0], 0, _chDWORD); 
				  _chDWORD:= SetWordToDWord(iDmb.RawData[n+1], 1, _chDWORD);
                end_if;
				if    (_modVar[m]=1) then
				  dDmbData[i].chData[m]:= SetBitToDWord((dDmbData[i].DData[m, j]<>_chDWORD), j, dDmbData[i].chData[m]);
				  dDmbData[i].DData[m, j]:= _chDWORD;
				elsif (_modVar[m]=2) then
				  dDmbData[i].chData[m]:= SetBitToDWord(dDmbData[i].RData[m, j]<>DWordToReal(_chDWORD), j, dDmbData[i].chData[m]);
				  dDmbData[i].RData[m, j]:= DWordToReal(_chDWORD);
				end_if;
			 3: (* BOOL *)
		        if    (_modSize[m]=1) then
				  dDmbData[i].chData[m]:= ANY_TO_DWORD(XOR_MASK_WORD(dDmbData[i].WData[m, j], _chWORD));
				  dDmbData[i].BWData[m]:= iDmb.RawData[n];
		        elsif (_modSize[m]=2) then
		          if GetBitFromWord(ANY_TO_WORD(dDmbData[i].nSwapWORD), m) then
		            _chDWORD:= SetWordToDWord(iDmb.RawData[n+0], 1, _chDWORD); 
				    _chDWORD:= SetWordToDWord(iDmb.RawData[n+1], 0, _chDWORD);
			      else		
		            _chDWORD:= SetWordToDWord(iDmb.RawData[n+0], 0, _chDWORD); 
				    _chDWORD:= SetWordToDWord(iDmb.RawData[n+1], 1, _chDWORD);
                  end_if;
				  dDmbData[i].chData[m]:= XOR_MASK_DWORD(dDmbData[i].BDData[m], _chDWORD);
				  dDmbData[i].BDData[m]:= _chDWORD;
				  j:= j+1;
				end_if;	
	    end_case;
      (* ------------------------------------------------ *)
      (*  AO, DO - запись данных в RawData *)
      elsif (_modType[m]=3 or _modType[m]=4) & not GetBitFromDWord(iDmb.State, 16+m) then 
        case _modVar[m] of
             0: (* WORD *)
												 
                iDmb.RawData[n]:= dDmbData[i].WData[m, j];
		   
          1, 2: (* DWORD, REAL *)
                if    (_modVar[m]=1) then
                  if GetBitFromWord(ANY_TO_WORD(dDmbData[i].nSwapWORD), m) then
                    iDmb.RawData[n+0]:= GetWordFromDWord(dDmbData[i].DData[m, j], 1); 
                    iDmb.RawData[n+1]:= GetWordFromDWord(dDmbData[i].DData[m, j], 0);      
                  else 
                    iDmb.RawData[n+0]:= GetWordFromDWord(dDmbData[i].DData[m, j], 0); 
                    iDmb.RawData[n+1]:= GetWordFromDWord(dDmbData[i].DData[m, j], 1);      
                  end_if;
                elsif (_modVar[m]=2) then
                  if GetBitFromWord(ANY_TO_WORD(dDmbData[i].nSwapWORD), m) then
                    iDmb.RawData[n+0]:= GetWordFromDWord(RealToDWord(dDmbData[i].RData[m, j]), 1); 
                    iDmb.RawData[n+1]:= GetWordFromDWord(RealToDWord(dDmbData[i].RData[m, j]), 0);      
                  else 
                    iDmb.RawData[n+0]:= GetWordFromDWord(RealToDWord(dDmbData[i].RData[m, j]), 0); 
                    iDmb.RawData[n+1]:= GetWordFromDWord(RealToDWord(dDmbData[i].RData[m, j]), 1);      
                  end_if;
                end_if;
		     3: (* BOOL *)
                if    (_modSize[m]=1) then
				  iDmb.RawData[n]:= dDmbData[i].BWData[m];
				elsif (_modSize[m]=2) then
		          if GetBitFromWord(ANY_TO_WORD(dDmbData[i].nSwapWORD), m) then
                    iDmb.RawData[n+0]:= GetWordFromDWord(dDmbData[i].BDData[m], 1); 
                    iDmb.RawData[n+1]:= GetWordFromDWord(dDmbData[i].BDData[m], 0);      
				  else 
                    iDmb.RawData[n+0]:= GetWordFromDWord(dDmbData[i].BDData[m], 0); 
                    iDmb.RawData[n+1]:= GetWordFromDWord(dDmbData[i].BDData[m], 1);      
				  end_if;
				  j:= j+1;
				end_if;  
        end_case;
      end_if;
    j:= j+1; end_while; 		 
    (* проход по каналам *)
    (* -------------------------------------------------- *)
  end_if;	
m:= m+1; end_while; 	  
(* ------------------------------------------------------ *)
(* Запись данных объекта MK541N *)
if not iDmb.eNotMK541N then
  m:= 0; while m<=7 do
    if _nRW[m] then
	  j:= 0;   while j<=_modSizeW[m]-1 do
	    if (iDmb.nOffs[m]+j)<=31 then 
	      dDioMK541NData[nDioMK541N].dMBData.regs[_nMK541Offs[m]+j]:= 
		    iDmb.RawData[iDmb.nOffs[m]+j];
	   end_if;		
	  j:= j+1; end_while;
    end_if;	
  m:= m+1; end_while;
end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* T02 Фильтр статуса неисправности *)
iDmb.mTimer2:= _fTimer(
  Start := eErrLink, 
  Stop  := iDmb.eErrLink or not eErrLink,
  tTimer:= iDmb.nTimer2,
  mTimer:= iDmb.mTimer2); 
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Конец логики *)
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Сохраняемые переменные (чтение при первом скане) *)
  if nPrgModify then
    iDmb.sTest_M0       := rDmb[i].sTest_M0;                     (* Режим: Тестирование Модуль [0] *)
    iDmb.sTest_M1       := rDmb[i].sTest_M1;                     (* Режим: Тестирование Модуль [1] *)
    iDmb.sTest_M2       := rDmb[i].sTest_M2;                     (* Режим: Тестирование Модуль [2] *)
    iDmb.sTest_M3       := rDmb[i].sTest_M3;                     (* Режим: Тестирование Модуль [3] *)
    iDmb.sTest_M4       := rDmb[i].sTest_M4;                     (* Режим: Тестирование Модуль [4] *)
    iDmb.sTest_M5       := rDmb[i].sTest_M5;                     (* Режим: Тестирование Модуль [5] *)
    iDmb.sTest_M6       := rDmb[i].sTest_M6;                     (* Режим: Тестирование Модуль [6] *)
    iDmb.sTest_M7       := rDmb[i].sTest_M7;                     (* Режим: Тестирование Модуль [7] *)
  end_if;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Cообщения для команд *)
  iDmb.oMsAck_State:= iDmb.MsAck_State;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Передача из Рабочего объекта *)
  dDmb[i]:= iDmb;
(* ------------------------------------------------------------------------------------------------------------------ *)
(* Отключение резевных объектов *)
end_if;
i:= i+1; end_while;
END_FUNCTION